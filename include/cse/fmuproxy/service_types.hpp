/**
 * Autogenerated by Thrift Compiler (0.12.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef CSE_FMUPROXY_SERVICE_TYPES_HPP
#define CSE_FMUPROXY_SERVICE_TYPES_HPP

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/TBase.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/stdcxx.h>


namespace fmuproxy { namespace thrift {

struct Status {
  enum type {
    OK_STATUS = 0,
    WARNING_STATUS = 1,
    DISCARD_STATUS = 2,
    ERROR_STATUS = 3,
    FATAL_STATUS = 4,
    PENDING_STATUS = 5
  };
};

extern const std::map<int, const char*> _Status_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const Status::type& val);

typedef std::string FmuId;

typedef std::string InstanceId;

typedef int64_t ValueReference;

typedef int64_t FmuState;

typedef std::vector<double>  DirectionalDerivative;

typedef std::vector<ValueReference>  ValueReferences;

typedef std::vector<int32_t>  IntArray;

typedef std::vector<double>  RealArray;

typedef std::vector<std::string>  StringArray;

typedef std::vector<bool>  BooleanArray;

typedef std::vector<class ScalarVariable>  ModelVariables;

class IntegerAttribute;

class RealAttribute;

class StringAttribute;

class BooleanAttribute;

class EnumerationAttribute;

class ScalarVariableAttribute;

class ScalarVariable;

class Unknown;

class ModelStructure;

class DefaultExperiment;

class StepResult;

class IntegerRead;

class RealRead;

class StringRead;

class BooleanRead;

class Solver;

class ModelDescription;

class CoSimulationAttributes;

class NoSuchFmuException;

class NoSuchInstanceException;

class NoSuchVariableException;

class UnsupportedOperationException;

class DirectionalDerivativeResult;

typedef struct _IntegerAttribute__isset {
  _IntegerAttribute__isset() : min(false), max(false), start(false), quantity(false) {}
  bool min :1;
  bool max :1;
  bool start :1;
  bool quantity :1;
} _IntegerAttribute__isset;

class IntegerAttribute : public virtual ::apache::thrift::TBase {
 public:

  IntegerAttribute(const IntegerAttribute&);
  IntegerAttribute& operator=(const IntegerAttribute&);
  IntegerAttribute() : min(0), max(0), start(0), quantity() {
  }

  virtual ~IntegerAttribute() throw();
  int32_t min;
  int32_t max;
  int32_t start;
  std::string quantity;

  _IntegerAttribute__isset __isset;

  void __set_min(const int32_t val);

  void __set_max(const int32_t val);

  void __set_start(const int32_t val);

  void __set_quantity(const std::string& val);

  bool operator == (const IntegerAttribute & rhs) const
  {
    if (!(min == rhs.min))
      return false;
    if (!(max == rhs.max))
      return false;
    if (!(start == rhs.start))
      return false;
    if (!(quantity == rhs.quantity))
      return false;
    return true;
  }
  bool operator != (const IntegerAttribute &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const IntegerAttribute & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(IntegerAttribute &a, IntegerAttribute &b);

std::ostream& operator<<(std::ostream& out, const IntegerAttribute& obj);

typedef struct _RealAttribute__isset {
  _RealAttribute__isset() : min(false), max(false), start(false), quantity(false) {}
  bool min :1;
  bool max :1;
  bool start :1;
  bool quantity :1;
} _RealAttribute__isset;

class RealAttribute : public virtual ::apache::thrift::TBase {
 public:

  RealAttribute(const RealAttribute&);
  RealAttribute& operator=(const RealAttribute&);
  RealAttribute() : min(0), max(0), start(0), quantity() {
  }

  virtual ~RealAttribute() throw();
  double min;
  double max;
  double start;
  std::string quantity;

  _RealAttribute__isset __isset;

  void __set_min(const double val);

  void __set_max(const double val);

  void __set_start(const double val);

  void __set_quantity(const std::string& val);

  bool operator == (const RealAttribute & rhs) const
  {
    if (!(min == rhs.min))
      return false;
    if (!(max == rhs.max))
      return false;
    if (!(start == rhs.start))
      return false;
    if (!(quantity == rhs.quantity))
      return false;
    return true;
  }
  bool operator != (const RealAttribute &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const RealAttribute & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(RealAttribute &a, RealAttribute &b);

std::ostream& operator<<(std::ostream& out, const RealAttribute& obj);

typedef struct _StringAttribute__isset {
  _StringAttribute__isset() : start(false) {}
  bool start :1;
} _StringAttribute__isset;

class StringAttribute : public virtual ::apache::thrift::TBase {
 public:

  StringAttribute(const StringAttribute&);
  StringAttribute& operator=(const StringAttribute&);
  StringAttribute() : start() {
  }

  virtual ~StringAttribute() throw();
  std::string start;

  _StringAttribute__isset __isset;

  void __set_start(const std::string& val);

  bool operator == (const StringAttribute & rhs) const
  {
    if (!(start == rhs.start))
      return false;
    return true;
  }
  bool operator != (const StringAttribute &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const StringAttribute & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(StringAttribute &a, StringAttribute &b);

std::ostream& operator<<(std::ostream& out, const StringAttribute& obj);

typedef struct _BooleanAttribute__isset {
  _BooleanAttribute__isset() : start(false) {}
  bool start :1;
} _BooleanAttribute__isset;

class BooleanAttribute : public virtual ::apache::thrift::TBase {
 public:

  BooleanAttribute(const BooleanAttribute&);
  BooleanAttribute& operator=(const BooleanAttribute&);
  BooleanAttribute() : start(0) {
  }

  virtual ~BooleanAttribute() throw();
  bool start;

  _BooleanAttribute__isset __isset;

  void __set_start(const bool val);

  bool operator == (const BooleanAttribute & rhs) const
  {
    if (!(start == rhs.start))
      return false;
    return true;
  }
  bool operator != (const BooleanAttribute &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const BooleanAttribute & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(BooleanAttribute &a, BooleanAttribute &b);

std::ostream& operator<<(std::ostream& out, const BooleanAttribute& obj);

typedef struct _EnumerationAttribute__isset {
  _EnumerationAttribute__isset() : min(false), max(false), start(false), quantity(false) {}
  bool min :1;
  bool max :1;
  bool start :1;
  bool quantity :1;
} _EnumerationAttribute__isset;

class EnumerationAttribute : public virtual ::apache::thrift::TBase {
 public:

  EnumerationAttribute(const EnumerationAttribute&);
  EnumerationAttribute& operator=(const EnumerationAttribute&);
  EnumerationAttribute() : min(0), max(0), start(0), quantity() {
  }

  virtual ~EnumerationAttribute() throw();
  int32_t min;
  int32_t max;
  int32_t start;
  std::string quantity;

  _EnumerationAttribute__isset __isset;

  void __set_min(const int32_t val);

  void __set_max(const int32_t val);

  void __set_start(const int32_t val);

  void __set_quantity(const std::string& val);

  bool operator == (const EnumerationAttribute & rhs) const
  {
    if (!(min == rhs.min))
      return false;
    if (!(max == rhs.max))
      return false;
    if (!(start == rhs.start))
      return false;
    if (!(quantity == rhs.quantity))
      return false;
    return true;
  }
  bool operator != (const EnumerationAttribute &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const EnumerationAttribute & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(EnumerationAttribute &a, EnumerationAttribute &b);

std::ostream& operator<<(std::ostream& out, const EnumerationAttribute& obj);

typedef struct _ScalarVariableAttribute__isset {
  _ScalarVariableAttribute__isset() : integer_attribute(false), real_attribute(false), string_attribute(false), boolean_attribute(false), enumeration_attribute(false) {}
  bool integer_attribute :1;
  bool real_attribute :1;
  bool string_attribute :1;
  bool boolean_attribute :1;
  bool enumeration_attribute :1;
} _ScalarVariableAttribute__isset;

class ScalarVariableAttribute : public virtual ::apache::thrift::TBase {
 public:

  ScalarVariableAttribute(const ScalarVariableAttribute&);
  ScalarVariableAttribute& operator=(const ScalarVariableAttribute&);
  ScalarVariableAttribute() {
  }

  virtual ~ScalarVariableAttribute() throw();
  IntegerAttribute integer_attribute;
  RealAttribute real_attribute;
  StringAttribute string_attribute;
  BooleanAttribute boolean_attribute;
  EnumerationAttribute enumeration_attribute;

  _ScalarVariableAttribute__isset __isset;

  void __set_integer_attribute(const IntegerAttribute& val);

  void __set_real_attribute(const RealAttribute& val);

  void __set_string_attribute(const StringAttribute& val);

  void __set_boolean_attribute(const BooleanAttribute& val);

  void __set_enumeration_attribute(const EnumerationAttribute& val);

  bool operator == (const ScalarVariableAttribute & rhs) const
  {
    if (__isset.integer_attribute != rhs.__isset.integer_attribute)
      return false;
    else if (__isset.integer_attribute && !(integer_attribute == rhs.integer_attribute))
      return false;
    if (__isset.real_attribute != rhs.__isset.real_attribute)
      return false;
    else if (__isset.real_attribute && !(real_attribute == rhs.real_attribute))
      return false;
    if (__isset.string_attribute != rhs.__isset.string_attribute)
      return false;
    else if (__isset.string_attribute && !(string_attribute == rhs.string_attribute))
      return false;
    if (__isset.boolean_attribute != rhs.__isset.boolean_attribute)
      return false;
    else if (__isset.boolean_attribute && !(boolean_attribute == rhs.boolean_attribute))
      return false;
    if (__isset.enumeration_attribute != rhs.__isset.enumeration_attribute)
      return false;
    else if (__isset.enumeration_attribute && !(enumeration_attribute == rhs.enumeration_attribute))
      return false;
    return true;
  }
  bool operator != (const ScalarVariableAttribute &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ScalarVariableAttribute & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ScalarVariableAttribute &a, ScalarVariableAttribute &b);

std::ostream& operator<<(std::ostream& out, const ScalarVariableAttribute& obj);

typedef struct _ScalarVariable__isset {
  _ScalarVariable__isset() : name(false), value_reference(false), description(false), initial(false), causality(false), variability(false), attribute(false) {}
  bool name :1;
  bool value_reference :1;
  bool description :1;
  bool initial :1;
  bool causality :1;
  bool variability :1;
  bool attribute :1;
} _ScalarVariable__isset;

class ScalarVariable : public virtual ::apache::thrift::TBase {
 public:

  ScalarVariable(const ScalarVariable&);
  ScalarVariable& operator=(const ScalarVariable&);
  ScalarVariable() : name(), value_reference(0), description(), initial(), causality(), variability() {
  }

  virtual ~ScalarVariable() throw();
  std::string name;
  ValueReference value_reference;
  std::string description;
  std::string initial;
  std::string causality;
  std::string variability;
  ScalarVariableAttribute attribute;

  _ScalarVariable__isset __isset;

  void __set_name(const std::string& val);

  void __set_value_reference(const ValueReference val);

  void __set_description(const std::string& val);

  void __set_initial(const std::string& val);

  void __set_causality(const std::string& val);

  void __set_variability(const std::string& val);

  void __set_attribute(const ScalarVariableAttribute& val);

  bool operator == (const ScalarVariable & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(value_reference == rhs.value_reference))
      return false;
    if (__isset.description != rhs.__isset.description)
      return false;
    else if (__isset.description && !(description == rhs.description))
      return false;
    if (__isset.initial != rhs.__isset.initial)
      return false;
    else if (__isset.initial && !(initial == rhs.initial))
      return false;
    if (__isset.causality != rhs.__isset.causality)
      return false;
    else if (__isset.causality && !(causality == rhs.causality))
      return false;
    if (__isset.variability != rhs.__isset.variability)
      return false;
    else if (__isset.variability && !(variability == rhs.variability))
      return false;
    if (!(attribute == rhs.attribute))
      return false;
    return true;
  }
  bool operator != (const ScalarVariable &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ScalarVariable & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ScalarVariable &a, ScalarVariable &b);

std::ostream& operator<<(std::ostream& out, const ScalarVariable& obj);

typedef struct _Unknown__isset {
  _Unknown__isset() : index(false), dependencies(false), dependencies_kind(false) {}
  bool index :1;
  bool dependencies :1;
  bool dependencies_kind :1;
} _Unknown__isset;

class Unknown : public virtual ::apache::thrift::TBase {
 public:

  Unknown(const Unknown&);
  Unknown& operator=(const Unknown&);
  Unknown() : index(0) {
  }

  virtual ~Unknown() throw();
  int32_t index;
  std::vector<int32_t>  dependencies;
  std::vector<std::string>  dependencies_kind;

  _Unknown__isset __isset;

  void __set_index(const int32_t val);

  void __set_dependencies(const std::vector<int32_t> & val);

  void __set_dependencies_kind(const std::vector<std::string> & val);

  bool operator == (const Unknown & rhs) const
  {
    if (!(index == rhs.index))
      return false;
    if (!(dependencies == rhs.dependencies))
      return false;
    if (!(dependencies_kind == rhs.dependencies_kind))
      return false;
    return true;
  }
  bool operator != (const Unknown &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Unknown & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Unknown &a, Unknown &b);

std::ostream& operator<<(std::ostream& out, const Unknown& obj);

typedef struct _ModelStructure__isset {
  _ModelStructure__isset() : outputs(false), derivatives(false), initial_unknowns(false) {}
  bool outputs :1;
  bool derivatives :1;
  bool initial_unknowns :1;
} _ModelStructure__isset;

class ModelStructure : public virtual ::apache::thrift::TBase {
 public:

  ModelStructure(const ModelStructure&);
  ModelStructure& operator=(const ModelStructure&);
  ModelStructure() {
  }

  virtual ~ModelStructure() throw();
  std::vector<Unknown>  outputs;
  std::vector<Unknown>  derivatives;
  std::vector<Unknown>  initial_unknowns;

  _ModelStructure__isset __isset;

  void __set_outputs(const std::vector<Unknown> & val);

  void __set_derivatives(const std::vector<Unknown> & val);

  void __set_initial_unknowns(const std::vector<Unknown> & val);

  bool operator == (const ModelStructure & rhs) const
  {
    if (!(outputs == rhs.outputs))
      return false;
    if (!(derivatives == rhs.derivatives))
      return false;
    if (!(initial_unknowns == rhs.initial_unknowns))
      return false;
    return true;
  }
  bool operator != (const ModelStructure &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ModelStructure & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ModelStructure &a, ModelStructure &b);

std::ostream& operator<<(std::ostream& out, const ModelStructure& obj);

typedef struct _DefaultExperiment__isset {
  _DefaultExperiment__isset() : startTime(false), stopTime(false), tolerance(false), stepSize(false) {}
  bool startTime :1;
  bool stopTime :1;
  bool tolerance :1;
  bool stepSize :1;
} _DefaultExperiment__isset;

class DefaultExperiment : public virtual ::apache::thrift::TBase {
 public:

  DefaultExperiment(const DefaultExperiment&);
  DefaultExperiment& operator=(const DefaultExperiment&);
  DefaultExperiment() : startTime(0), stopTime(0), tolerance(0), stepSize(0) {
  }

  virtual ~DefaultExperiment() throw();
  double startTime;
  double stopTime;
  double tolerance;
  double stepSize;

  _DefaultExperiment__isset __isset;

  void __set_startTime(const double val);

  void __set_stopTime(const double val);

  void __set_tolerance(const double val);

  void __set_stepSize(const double val);

  bool operator == (const DefaultExperiment & rhs) const
  {
    if (!(startTime == rhs.startTime))
      return false;
    if (!(stopTime == rhs.stopTime))
      return false;
    if (!(tolerance == rhs.tolerance))
      return false;
    if (!(stepSize == rhs.stepSize))
      return false;
    return true;
  }
  bool operator != (const DefaultExperiment &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DefaultExperiment & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(DefaultExperiment &a, DefaultExperiment &b);

std::ostream& operator<<(std::ostream& out, const DefaultExperiment& obj);

typedef struct _StepResult__isset {
  _StepResult__isset() : status(false), simulation_time(false) {}
  bool status :1;
  bool simulation_time :1;
} _StepResult__isset;

class StepResult : public virtual ::apache::thrift::TBase {
 public:

  StepResult(const StepResult&);
  StepResult& operator=(const StepResult&);
  StepResult() : status((Status::type)0), simulation_time(0) {
  }

  virtual ~StepResult() throw();
  Status::type status;
  double simulation_time;

  _StepResult__isset __isset;

  void __set_status(const Status::type val);

  void __set_simulation_time(const double val);

  bool operator == (const StepResult & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (!(simulation_time == rhs.simulation_time))
      return false;
    return true;
  }
  bool operator != (const StepResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const StepResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(StepResult &a, StepResult &b);

std::ostream& operator<<(std::ostream& out, const StepResult& obj);

typedef struct _IntegerRead__isset {
  _IntegerRead__isset() : value(false), status(false) {}
  bool value :1;
  bool status :1;
} _IntegerRead__isset;

class IntegerRead : public virtual ::apache::thrift::TBase {
 public:

  IntegerRead(const IntegerRead&);
  IntegerRead& operator=(const IntegerRead&);
  IntegerRead() : status((Status::type)0) {
  }

  virtual ~IntegerRead() throw();
  std::vector<int32_t>  value;
  Status::type status;

  _IntegerRead__isset __isset;

  void __set_value(const std::vector<int32_t> & val);

  void __set_status(const Status::type val);

  bool operator == (const IntegerRead & rhs) const
  {
    if (!(value == rhs.value))
      return false;
    if (!(status == rhs.status))
      return false;
    return true;
  }
  bool operator != (const IntegerRead &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const IntegerRead & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(IntegerRead &a, IntegerRead &b);

std::ostream& operator<<(std::ostream& out, const IntegerRead& obj);

typedef struct _RealRead__isset {
  _RealRead__isset() : value(false), status(false) {}
  bool value :1;
  bool status :1;
} _RealRead__isset;

class RealRead : public virtual ::apache::thrift::TBase {
 public:

  RealRead(const RealRead&);
  RealRead& operator=(const RealRead&);
  RealRead() : status((Status::type)0) {
  }

  virtual ~RealRead() throw();
  std::vector<double>  value;
  Status::type status;

  _RealRead__isset __isset;

  void __set_value(const std::vector<double> & val);

  void __set_status(const Status::type val);

  bool operator == (const RealRead & rhs) const
  {
    if (!(value == rhs.value))
      return false;
    if (!(status == rhs.status))
      return false;
    return true;
  }
  bool operator != (const RealRead &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const RealRead & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(RealRead &a, RealRead &b);

std::ostream& operator<<(std::ostream& out, const RealRead& obj);

typedef struct _StringRead__isset {
  _StringRead__isset() : value(false), status(false) {}
  bool value :1;
  bool status :1;
} _StringRead__isset;

class StringRead : public virtual ::apache::thrift::TBase {
 public:

  StringRead(const StringRead&);
  StringRead& operator=(const StringRead&);
  StringRead() : status((Status::type)0) {
  }

  virtual ~StringRead() throw();
  std::vector<std::string>  value;
  Status::type status;

  _StringRead__isset __isset;

  void __set_value(const std::vector<std::string> & val);

  void __set_status(const Status::type val);

  bool operator == (const StringRead & rhs) const
  {
    if (!(value == rhs.value))
      return false;
    if (!(status == rhs.status))
      return false;
    return true;
  }
  bool operator != (const StringRead &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const StringRead & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(StringRead &a, StringRead &b);

std::ostream& operator<<(std::ostream& out, const StringRead& obj);

typedef struct _BooleanRead__isset {
  _BooleanRead__isset() : value(false), status(false) {}
  bool value :1;
  bool status :1;
} _BooleanRead__isset;

class BooleanRead : public virtual ::apache::thrift::TBase {
 public:

  BooleanRead(const BooleanRead&);
  BooleanRead& operator=(const BooleanRead&);
  BooleanRead() : status((Status::type)0) {
  }

  virtual ~BooleanRead() throw();
  std::vector<bool>  value;
  Status::type status;

  _BooleanRead__isset __isset;

  void __set_value(const std::vector<bool> & val);

  void __set_status(const Status::type val);

  bool operator == (const BooleanRead & rhs) const
  {
    if (!(value == rhs.value))
      return false;
    if (!(status == rhs.status))
      return false;
    return true;
  }
  bool operator != (const BooleanRead &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const BooleanRead & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(BooleanRead &a, BooleanRead &b);

std::ostream& operator<<(std::ostream& out, const BooleanRead& obj);

typedef struct _Solver__isset {
  _Solver__isset() : name(false), settings(false) {}
  bool name :1;
  bool settings :1;
} _Solver__isset;

class Solver : public virtual ::apache::thrift::TBase {
 public:

  Solver(const Solver&);
  Solver& operator=(const Solver&);
  Solver() : name(), settings() {
  }

  virtual ~Solver() throw();
  std::string name;
  std::string settings;

  _Solver__isset __isset;

  void __set_name(const std::string& val);

  void __set_settings(const std::string& val);

  bool operator == (const Solver & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(settings == rhs.settings))
      return false;
    return true;
  }
  bool operator != (const Solver &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Solver & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Solver &a, Solver &b);

std::ostream& operator<<(std::ostream& out, const Solver& obj);

typedef struct _ModelDescription__isset {
  _ModelDescription__isset() : guid(false), fmi_version(false), modelName(false), license(false), copyright(false), author(false), version(false), description(false), generation_tool(false), generation_date_and_time(false), default_experiment(false), variable_naming_convention(false), model_variables(false), model_structure(false) {}
  bool guid :1;
  bool fmi_version :1;
  bool modelName :1;
  bool license :1;
  bool copyright :1;
  bool author :1;
  bool version :1;
  bool description :1;
  bool generation_tool :1;
  bool generation_date_and_time :1;
  bool default_experiment :1;
  bool variable_naming_convention :1;
  bool model_variables :1;
  bool model_structure :1;
} _ModelDescription__isset;

class ModelDescription : public virtual ::apache::thrift::TBase {
 public:

  ModelDescription(const ModelDescription&);
  ModelDescription& operator=(const ModelDescription&);
  ModelDescription() : guid(), fmi_version(), modelName(), license(), copyright(), author(), version(), description(), generation_tool(), generation_date_and_time(), variable_naming_convention() {
  }

  virtual ~ModelDescription() throw();
  std::string guid;
  std::string fmi_version;
  std::string modelName;
  std::string license;
  std::string copyright;
  std::string author;
  std::string version;
  std::string description;
  std::string generation_tool;
  std::string generation_date_and_time;
  DefaultExperiment default_experiment;
  std::string variable_naming_convention;
  ModelVariables model_variables;
  ModelStructure model_structure;

  _ModelDescription__isset __isset;

  void __set_guid(const std::string& val);

  void __set_fmi_version(const std::string& val);

  void __set_modelName(const std::string& val);

  void __set_license(const std::string& val);

  void __set_copyright(const std::string& val);

  void __set_author(const std::string& val);

  void __set_version(const std::string& val);

  void __set_description(const std::string& val);

  void __set_generation_tool(const std::string& val);

  void __set_generation_date_and_time(const std::string& val);

  void __set_default_experiment(const DefaultExperiment& val);

  void __set_variable_naming_convention(const std::string& val);

  void __set_model_variables(const ModelVariables& val);

  void __set_model_structure(const ModelStructure& val);

  bool operator == (const ModelDescription & rhs) const
  {
    if (!(guid == rhs.guid))
      return false;
    if (!(fmi_version == rhs.fmi_version))
      return false;
    if (!(modelName == rhs.modelName))
      return false;
    if (__isset.license != rhs.__isset.license)
      return false;
    else if (__isset.license && !(license == rhs.license))
      return false;
    if (__isset.copyright != rhs.__isset.copyright)
      return false;
    else if (__isset.copyright && !(copyright == rhs.copyright))
      return false;
    if (__isset.author != rhs.__isset.author)
      return false;
    else if (__isset.author && !(author == rhs.author))
      return false;
    if (__isset.version != rhs.__isset.version)
      return false;
    else if (__isset.version && !(version == rhs.version))
      return false;
    if (__isset.description != rhs.__isset.description)
      return false;
    else if (__isset.description && !(description == rhs.description))
      return false;
    if (__isset.generation_tool != rhs.__isset.generation_tool)
      return false;
    else if (__isset.generation_tool && !(generation_tool == rhs.generation_tool))
      return false;
    if (__isset.generation_date_and_time != rhs.__isset.generation_date_and_time)
      return false;
    else if (__isset.generation_date_and_time && !(generation_date_and_time == rhs.generation_date_and_time))
      return false;
    if (__isset.default_experiment != rhs.__isset.default_experiment)
      return false;
    else if (__isset.default_experiment && !(default_experiment == rhs.default_experiment))
      return false;
    if (__isset.variable_naming_convention != rhs.__isset.variable_naming_convention)
      return false;
    else if (__isset.variable_naming_convention && !(variable_naming_convention == rhs.variable_naming_convention))
      return false;
    if (!(model_variables == rhs.model_variables))
      return false;
    if (!(model_structure == rhs.model_structure))
      return false;
    return true;
  }
  bool operator != (const ModelDescription &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ModelDescription & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ModelDescription &a, ModelDescription &b);

std::ostream& operator<<(std::ostream& out, const ModelDescription& obj);

typedef struct _CoSimulationAttributes__isset {
  _CoSimulationAttributes__isset() : model_identifier(false), can_get_and_set_fmu_state(false), can_serialize_fmu_state(false), provides_directional_derivative(false), can_handle_variable_communication_step_size(false), can_interpolate_inputs(false), max_output_derivative_order(false) {}
  bool model_identifier :1;
  bool can_get_and_set_fmu_state :1;
  bool can_serialize_fmu_state :1;
  bool provides_directional_derivative :1;
  bool can_handle_variable_communication_step_size :1;
  bool can_interpolate_inputs :1;
  bool max_output_derivative_order :1;
} _CoSimulationAttributes__isset;

class CoSimulationAttributes : public virtual ::apache::thrift::TBase {
 public:

  CoSimulationAttributes(const CoSimulationAttributes&);
  CoSimulationAttributes& operator=(const CoSimulationAttributes&);
  CoSimulationAttributes() : model_identifier(), can_get_and_set_fmu_state(0), can_serialize_fmu_state(0), provides_directional_derivative(0), can_handle_variable_communication_step_size(0), can_interpolate_inputs(0), max_output_derivative_order(0) {
  }

  virtual ~CoSimulationAttributes() throw();
  std::string model_identifier;
  bool can_get_and_set_fmu_state;
  bool can_serialize_fmu_state;
  bool provides_directional_derivative;
  bool can_handle_variable_communication_step_size;
  bool can_interpolate_inputs;
  int32_t max_output_derivative_order;

  _CoSimulationAttributes__isset __isset;

  void __set_model_identifier(const std::string& val);

  void __set_can_get_and_set_fmu_state(const bool val);

  void __set_can_serialize_fmu_state(const bool val);

  void __set_provides_directional_derivative(const bool val);

  void __set_can_handle_variable_communication_step_size(const bool val);

  void __set_can_interpolate_inputs(const bool val);

  void __set_max_output_derivative_order(const int32_t val);

  bool operator == (const CoSimulationAttributes & rhs) const
  {
    if (!(model_identifier == rhs.model_identifier))
      return false;
    if (!(can_get_and_set_fmu_state == rhs.can_get_and_set_fmu_state))
      return false;
    if (!(can_serialize_fmu_state == rhs.can_serialize_fmu_state))
      return false;
    if (!(provides_directional_derivative == rhs.provides_directional_derivative))
      return false;
    if (!(can_handle_variable_communication_step_size == rhs.can_handle_variable_communication_step_size))
      return false;
    if (!(can_interpolate_inputs == rhs.can_interpolate_inputs))
      return false;
    if (!(max_output_derivative_order == rhs.max_output_derivative_order))
      return false;
    return true;
  }
  bool operator != (const CoSimulationAttributes &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CoSimulationAttributes & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(CoSimulationAttributes &a, CoSimulationAttributes &b);

std::ostream& operator<<(std::ostream& out, const CoSimulationAttributes& obj);

typedef struct _NoSuchFmuException__isset {
  _NoSuchFmuException__isset() : message(false) {}
  bool message :1;
} _NoSuchFmuException__isset;

class NoSuchFmuException : public ::apache::thrift::TException {
 public:

  NoSuchFmuException(const NoSuchFmuException&);
  NoSuchFmuException& operator=(const NoSuchFmuException&);
  NoSuchFmuException() : message() {
  }

  virtual ~NoSuchFmuException() throw();
  std::string message;

  _NoSuchFmuException__isset __isset;

  void __set_message(const std::string& val);

  bool operator == (const NoSuchFmuException & rhs) const
  {
    if (!(message == rhs.message))
      return false;
    return true;
  }
  bool operator != (const NoSuchFmuException &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoSuchFmuException & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const throw();
};

void swap(NoSuchFmuException &a, NoSuchFmuException &b);

std::ostream& operator<<(std::ostream& out, const NoSuchFmuException& obj);

typedef struct _NoSuchInstanceException__isset {
  _NoSuchInstanceException__isset() : message(false) {}
  bool message :1;
} _NoSuchInstanceException__isset;

class NoSuchInstanceException : public ::apache::thrift::TException {
 public:

  NoSuchInstanceException(const NoSuchInstanceException&);
  NoSuchInstanceException& operator=(const NoSuchInstanceException&);
  NoSuchInstanceException() : message() {
  }

  virtual ~NoSuchInstanceException() throw();
  std::string message;

  _NoSuchInstanceException__isset __isset;

  void __set_message(const std::string& val);

  bool operator == (const NoSuchInstanceException & rhs) const
  {
    if (!(message == rhs.message))
      return false;
    return true;
  }
  bool operator != (const NoSuchInstanceException &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoSuchInstanceException & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const throw();
};

void swap(NoSuchInstanceException &a, NoSuchInstanceException &b);

std::ostream& operator<<(std::ostream& out, const NoSuchInstanceException& obj);

typedef struct _NoSuchVariableException__isset {
  _NoSuchVariableException__isset() : message(false) {}
  bool message :1;
} _NoSuchVariableException__isset;

class NoSuchVariableException : public ::apache::thrift::TException {
 public:

  NoSuchVariableException(const NoSuchVariableException&);
  NoSuchVariableException& operator=(const NoSuchVariableException&);
  NoSuchVariableException() : message() {
  }

  virtual ~NoSuchVariableException() throw();
  std::string message;

  _NoSuchVariableException__isset __isset;

  void __set_message(const std::string& val);

  bool operator == (const NoSuchVariableException & rhs) const
  {
    if (!(message == rhs.message))
      return false;
    return true;
  }
  bool operator != (const NoSuchVariableException &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoSuchVariableException & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const throw();
};

void swap(NoSuchVariableException &a, NoSuchVariableException &b);

std::ostream& operator<<(std::ostream& out, const NoSuchVariableException& obj);

typedef struct _UnsupportedOperationException__isset {
  _UnsupportedOperationException__isset() : message(false) {}
  bool message :1;
} _UnsupportedOperationException__isset;

class UnsupportedOperationException : public ::apache::thrift::TException {
 public:

  UnsupportedOperationException(const UnsupportedOperationException&);
  UnsupportedOperationException& operator=(const UnsupportedOperationException&);
  UnsupportedOperationException() : message() {
  }

  virtual ~UnsupportedOperationException() throw();
  std::string message;

  _UnsupportedOperationException__isset __isset;

  void __set_message(const std::string& val);

  bool operator == (const UnsupportedOperationException & rhs) const
  {
    if (!(message == rhs.message))
      return false;
    return true;
  }
  bool operator != (const UnsupportedOperationException &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UnsupportedOperationException & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const throw();
};

void swap(UnsupportedOperationException &a, UnsupportedOperationException &b);

std::ostream& operator<<(std::ostream& out, const UnsupportedOperationException& obj);

typedef struct _DirectionalDerivativeResult__isset {
  _DirectionalDerivativeResult__isset() : dv_unknown_ref(false), status(false) {}
  bool dv_unknown_ref :1;
  bool status :1;
} _DirectionalDerivativeResult__isset;

class DirectionalDerivativeResult : public virtual ::apache::thrift::TBase {
 public:

  DirectionalDerivativeResult(const DirectionalDerivativeResult&);
  DirectionalDerivativeResult& operator=(const DirectionalDerivativeResult&);
  DirectionalDerivativeResult() : status((Status::type)0) {
  }

  virtual ~DirectionalDerivativeResult() throw();
  DirectionalDerivative dv_unknown_ref;
  Status::type status;

  _DirectionalDerivativeResult__isset __isset;

  void __set_dv_unknown_ref(const DirectionalDerivative& val);

  void __set_status(const Status::type val);

  bool operator == (const DirectionalDerivativeResult & rhs) const
  {
    if (!(dv_unknown_ref == rhs.dv_unknown_ref))
      return false;
    if (!(status == rhs.status))
      return false;
    return true;
  }
  bool operator != (const DirectionalDerivativeResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DirectionalDerivativeResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(DirectionalDerivativeResult &a, DirectionalDerivativeResult &b);

std::ostream& operator<<(std::ostream& out, const DirectionalDerivativeResult& obj);

}} // namespace

#endif
