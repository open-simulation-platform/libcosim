/**
 * Autogenerated by Thrift Compiler (0.12.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include <cosim/fmuproxy/service_types.hpp>

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace fmuproxy { namespace thrift {

int _kStatusValues[] = {
  Status::OK_STATUS,
  Status::WARNING_STATUS,
  Status::DISCARD_STATUS,
  Status::ERROR_STATUS,
  Status::FATAL_STATUS,
  Status::PENDING_STATUS
};
const char* _kStatusNames[] = {
  "OK_STATUS",
  "WARNING_STATUS",
  "DISCARD_STATUS",
  "ERROR_STATUS",
  "FATAL_STATUS",
  "PENDING_STATUS"
};
const std::map<int, const char*> _Status_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _kStatusValues, _kStatusNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const Status::type& val) {
  std::map<int, const char*>::const_iterator it = _Status_VALUES_TO_NAMES.find(val);
  if (it != _Status_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}


IntegerAttribute::~IntegerAttribute() throw() {
}


void IntegerAttribute::__set_min(const int32_t val) {
  this->min = val;
}

void IntegerAttribute::__set_max(const int32_t val) {
  this->max = val;
}

void IntegerAttribute::__set_start(const int32_t val) {
  this->start = val;
}

void IntegerAttribute::__set_quantity(const std::string& val) {
  this->quantity = val;
}
std::ostream& operator<<(std::ostream& out, const IntegerAttribute& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t IntegerAttribute::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->min);
          this->__isset.min = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->max);
          this->__isset.max = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->start);
          this->__isset.start = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->quantity);
          this->__isset.quantity = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t IntegerAttribute::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("IntegerAttribute");

  xfer += oprot->writeFieldBegin("min", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->min);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("max", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->max);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("start", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->start);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("quantity", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->quantity);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(IntegerAttribute &a, IntegerAttribute &b) {
  using ::std::swap;
  swap(a.min, b.min);
  swap(a.max, b.max);
  swap(a.start, b.start);
  swap(a.quantity, b.quantity);
  swap(a.__isset, b.__isset);
}

IntegerAttribute::IntegerAttribute(const IntegerAttribute& other0) {
  min = other0.min;
  max = other0.max;
  start = other0.start;
  quantity = other0.quantity;
  __isset = other0.__isset;
}
IntegerAttribute& IntegerAttribute::operator=(const IntegerAttribute& other1) {
  min = other1.min;
  max = other1.max;
  start = other1.start;
  quantity = other1.quantity;
  __isset = other1.__isset;
  return *this;
}
void IntegerAttribute::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "IntegerAttribute(";
  out << "min=" << to_string(min);
  out << ", " << "max=" << to_string(max);
  out << ", " << "start=" << to_string(start);
  out << ", " << "quantity=" << to_string(quantity);
  out << ")";
}


RealAttribute::~RealAttribute() throw() {
}


void RealAttribute::__set_min(const double val) {
  this->min = val;
}

void RealAttribute::__set_max(const double val) {
  this->max = val;
}

void RealAttribute::__set_start(const double val) {
  this->start = val;
}

void RealAttribute::__set_quantity(const std::string& val) {
  this->quantity = val;
}
std::ostream& operator<<(std::ostream& out, const RealAttribute& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t RealAttribute::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->min);
          this->__isset.min = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->max);
          this->__isset.max = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->start);
          this->__isset.start = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->quantity);
          this->__isset.quantity = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t RealAttribute::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("RealAttribute");

  xfer += oprot->writeFieldBegin("min", ::apache::thrift::protocol::T_DOUBLE, 1);
  xfer += oprot->writeDouble(this->min);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("max", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->max);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("start", ::apache::thrift::protocol::T_DOUBLE, 3);
  xfer += oprot->writeDouble(this->start);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("quantity", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->quantity);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RealAttribute &a, RealAttribute &b) {
  using ::std::swap;
  swap(a.min, b.min);
  swap(a.max, b.max);
  swap(a.start, b.start);
  swap(a.quantity, b.quantity);
  swap(a.__isset, b.__isset);
}

RealAttribute::RealAttribute(const RealAttribute& other2) {
  min = other2.min;
  max = other2.max;
  start = other2.start;
  quantity = other2.quantity;
  __isset = other2.__isset;
}
RealAttribute& RealAttribute::operator=(const RealAttribute& other3) {
  min = other3.min;
  max = other3.max;
  start = other3.start;
  quantity = other3.quantity;
  __isset = other3.__isset;
  return *this;
}
void RealAttribute::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "RealAttribute(";
  out << "min=" << to_string(min);
  out << ", " << "max=" << to_string(max);
  out << ", " << "start=" << to_string(start);
  out << ", " << "quantity=" << to_string(quantity);
  out << ")";
}


StringAttribute::~StringAttribute() throw() {
}


void StringAttribute::__set_start(const std::string& val) {
  this->start = val;
}
std::ostream& operator<<(std::ostream& out, const StringAttribute& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t StringAttribute::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->start);
          this->__isset.start = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t StringAttribute::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("StringAttribute");

  xfer += oprot->writeFieldBegin("start", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->start);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(StringAttribute &a, StringAttribute &b) {
  using ::std::swap;
  swap(a.start, b.start);
  swap(a.__isset, b.__isset);
}

StringAttribute::StringAttribute(const StringAttribute& other4) {
  start = other4.start;
  __isset = other4.__isset;
}
StringAttribute& StringAttribute::operator=(const StringAttribute& other5) {
  start = other5.start;
  __isset = other5.__isset;
  return *this;
}
void StringAttribute::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "StringAttribute(";
  out << "start=" << to_string(start);
  out << ")";
}


BooleanAttribute::~BooleanAttribute() throw() {
}


void BooleanAttribute::__set_start(const bool val) {
  this->start = val;
}
std::ostream& operator<<(std::ostream& out, const BooleanAttribute& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t BooleanAttribute::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->start);
          this->__isset.start = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BooleanAttribute::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("BooleanAttribute");

  xfer += oprot->writeFieldBegin("start", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->start);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BooleanAttribute &a, BooleanAttribute &b) {
  using ::std::swap;
  swap(a.start, b.start);
  swap(a.__isset, b.__isset);
}

BooleanAttribute::BooleanAttribute(const BooleanAttribute& other6) {
  start = other6.start;
  __isset = other6.__isset;
}
BooleanAttribute& BooleanAttribute::operator=(const BooleanAttribute& other7) {
  start = other7.start;
  __isset = other7.__isset;
  return *this;
}
void BooleanAttribute::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "BooleanAttribute(";
  out << "start=" << to_string(start);
  out << ")";
}


EnumerationAttribute::~EnumerationAttribute() throw() {
}


void EnumerationAttribute::__set_min(const int32_t val) {
  this->min = val;
}

void EnumerationAttribute::__set_max(const int32_t val) {
  this->max = val;
}

void EnumerationAttribute::__set_start(const int32_t val) {
  this->start = val;
}

void EnumerationAttribute::__set_quantity(const std::string& val) {
  this->quantity = val;
}
std::ostream& operator<<(std::ostream& out, const EnumerationAttribute& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t EnumerationAttribute::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->min);
          this->__isset.min = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->max);
          this->__isset.max = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->start);
          this->__isset.start = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->quantity);
          this->__isset.quantity = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t EnumerationAttribute::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("EnumerationAttribute");

  xfer += oprot->writeFieldBegin("min", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->min);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("max", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->max);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("start", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->start);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("quantity", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->quantity);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(EnumerationAttribute &a, EnumerationAttribute &b) {
  using ::std::swap;
  swap(a.min, b.min);
  swap(a.max, b.max);
  swap(a.start, b.start);
  swap(a.quantity, b.quantity);
  swap(a.__isset, b.__isset);
}

EnumerationAttribute::EnumerationAttribute(const EnumerationAttribute& other8) {
  min = other8.min;
  max = other8.max;
  start = other8.start;
  quantity = other8.quantity;
  __isset = other8.__isset;
}
EnumerationAttribute& EnumerationAttribute::operator=(const EnumerationAttribute& other9) {
  min = other9.min;
  max = other9.max;
  start = other9.start;
  quantity = other9.quantity;
  __isset = other9.__isset;
  return *this;
}
void EnumerationAttribute::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "EnumerationAttribute(";
  out << "min=" << to_string(min);
  out << ", " << "max=" << to_string(max);
  out << ", " << "start=" << to_string(start);
  out << ", " << "quantity=" << to_string(quantity);
  out << ")";
}


ScalarVariableAttribute::~ScalarVariableAttribute() throw() {
}


void ScalarVariableAttribute::__set_integer_attribute(const IntegerAttribute& val) {
  this->integer_attribute = val;
__isset.integer_attribute = true;
}

void ScalarVariableAttribute::__set_real_attribute(const RealAttribute& val) {
  this->real_attribute = val;
__isset.real_attribute = true;
}

void ScalarVariableAttribute::__set_string_attribute(const StringAttribute& val) {
  this->string_attribute = val;
__isset.string_attribute = true;
}

void ScalarVariableAttribute::__set_boolean_attribute(const BooleanAttribute& val) {
  this->boolean_attribute = val;
__isset.boolean_attribute = true;
}

void ScalarVariableAttribute::__set_enumeration_attribute(const EnumerationAttribute& val) {
  this->enumeration_attribute = val;
__isset.enumeration_attribute = true;
}
std::ostream& operator<<(std::ostream& out, const ScalarVariableAttribute& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ScalarVariableAttribute::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->integer_attribute.read(iprot);
          this->__isset.integer_attribute = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->real_attribute.read(iprot);
          this->__isset.real_attribute = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->string_attribute.read(iprot);
          this->__isset.string_attribute = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->boolean_attribute.read(iprot);
          this->__isset.boolean_attribute = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->enumeration_attribute.read(iprot);
          this->__isset.enumeration_attribute = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ScalarVariableAttribute::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ScalarVariableAttribute");

  if (this->__isset.integer_attribute) {
    xfer += oprot->writeFieldBegin("integer_attribute", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->integer_attribute.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.real_attribute) {
    xfer += oprot->writeFieldBegin("real_attribute", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->real_attribute.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.string_attribute) {
    xfer += oprot->writeFieldBegin("string_attribute", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->string_attribute.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.boolean_attribute) {
    xfer += oprot->writeFieldBegin("boolean_attribute", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->boolean_attribute.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.enumeration_attribute) {
    xfer += oprot->writeFieldBegin("enumeration_attribute", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->enumeration_attribute.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ScalarVariableAttribute &a, ScalarVariableAttribute &b) {
  using ::std::swap;
  swap(a.integer_attribute, b.integer_attribute);
  swap(a.real_attribute, b.real_attribute);
  swap(a.string_attribute, b.string_attribute);
  swap(a.boolean_attribute, b.boolean_attribute);
  swap(a.enumeration_attribute, b.enumeration_attribute);
  swap(a.__isset, b.__isset);
}

ScalarVariableAttribute::ScalarVariableAttribute(const ScalarVariableAttribute& other10) {
  integer_attribute = other10.integer_attribute;
  real_attribute = other10.real_attribute;
  string_attribute = other10.string_attribute;
  boolean_attribute = other10.boolean_attribute;
  enumeration_attribute = other10.enumeration_attribute;
  __isset = other10.__isset;
}
ScalarVariableAttribute& ScalarVariableAttribute::operator=(const ScalarVariableAttribute& other11) {
  integer_attribute = other11.integer_attribute;
  real_attribute = other11.real_attribute;
  string_attribute = other11.string_attribute;
  boolean_attribute = other11.boolean_attribute;
  enumeration_attribute = other11.enumeration_attribute;
  __isset = other11.__isset;
  return *this;
}
void ScalarVariableAttribute::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ScalarVariableAttribute(";
  out << "integer_attribute="; (__isset.integer_attribute ? (out << to_string(integer_attribute)) : (out << "<null>"));
  out << ", " << "real_attribute="; (__isset.real_attribute ? (out << to_string(real_attribute)) : (out << "<null>"));
  out << ", " << "string_attribute="; (__isset.string_attribute ? (out << to_string(string_attribute)) : (out << "<null>"));
  out << ", " << "boolean_attribute="; (__isset.boolean_attribute ? (out << to_string(boolean_attribute)) : (out << "<null>"));
  out << ", " << "enumeration_attribute="; (__isset.enumeration_attribute ? (out << to_string(enumeration_attribute)) : (out << "<null>"));
  out << ")";
}


ScalarVariable::~ScalarVariable() throw() {
}


void ScalarVariable::__set_name(const std::string& val) {
  this->name = val;
}

void ScalarVariable::__set_value_reference(const ValueReference val) {
  this->value_reference = val;
}

void ScalarVariable::__set_description(const std::string& val) {
  this->description = val;
__isset.description = true;
}

void ScalarVariable::__set_initial(const std::string& val) {
  this->initial = val;
__isset.initial = true;
}

void ScalarVariable::__set_causality(const std::string& val) {
  this->causality = val;
__isset.causality = true;
}

void ScalarVariable::__set_variability(const std::string& val) {
  this->variability = val;
__isset.variability = true;
}

void ScalarVariable::__set_attribute(const ScalarVariableAttribute& val) {
  this->attribute = val;
}
std::ostream& operator<<(std::ostream& out, const ScalarVariable& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ScalarVariable::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->value_reference);
          this->__isset.value_reference = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->description);
          this->__isset.description = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->initial);
          this->__isset.initial = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->causality);
          this->__isset.causality = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->variability);
          this->__isset.variability = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->attribute.read(iprot);
          this->__isset.attribute = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ScalarVariable::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ScalarVariable");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value_reference", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->value_reference);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.description) {
    xfer += oprot->writeFieldBegin("description", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->description);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.initial) {
    xfer += oprot->writeFieldBegin("initial", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->initial);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.causality) {
    xfer += oprot->writeFieldBegin("causality", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->causality);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.variability) {
    xfer += oprot->writeFieldBegin("variability", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->variability);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("attribute", ::apache::thrift::protocol::T_STRUCT, 7);
  xfer += this->attribute.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ScalarVariable &a, ScalarVariable &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.value_reference, b.value_reference);
  swap(a.description, b.description);
  swap(a.initial, b.initial);
  swap(a.causality, b.causality);
  swap(a.variability, b.variability);
  swap(a.attribute, b.attribute);
  swap(a.__isset, b.__isset);
}

ScalarVariable::ScalarVariable(const ScalarVariable& other12) {
  name = other12.name;
  value_reference = other12.value_reference;
  description = other12.description;
  initial = other12.initial;
  causality = other12.causality;
  variability = other12.variability;
  attribute = other12.attribute;
  __isset = other12.__isset;
}
ScalarVariable& ScalarVariable::operator=(const ScalarVariable& other13) {
  name = other13.name;
  value_reference = other13.value_reference;
  description = other13.description;
  initial = other13.initial;
  causality = other13.causality;
  variability = other13.variability;
  attribute = other13.attribute;
  __isset = other13.__isset;
  return *this;
}
void ScalarVariable::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ScalarVariable(";
  out << "name=" << to_string(name);
  out << ", " << "value_reference=" << to_string(value_reference);
  out << ", " << "description="; (__isset.description ? (out << to_string(description)) : (out << "<null>"));
  out << ", " << "initial="; (__isset.initial ? (out << to_string(initial)) : (out << "<null>"));
  out << ", " << "causality="; (__isset.causality ? (out << to_string(causality)) : (out << "<null>"));
  out << ", " << "variability="; (__isset.variability ? (out << to_string(variability)) : (out << "<null>"));
  out << ", " << "attribute=" << to_string(attribute);
  out << ")";
}


Unknown::~Unknown() throw() {
}


void Unknown::__set_index(const int32_t val) {
  this->index = val;
}

void Unknown::__set_dependencies(const std::vector<int32_t> & val) {
  this->dependencies = val;
}

void Unknown::__set_dependencies_kind(const std::vector<std::string> & val) {
  this->dependencies_kind = val;
}
std::ostream& operator<<(std::ostream& out, const Unknown& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Unknown::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->index);
          this->__isset.index = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->dependencies.clear();
            uint32_t _size14;
            ::apache::thrift::protocol::TType _etype17;
            xfer += iprot->readListBegin(_etype17, _size14);
            this->dependencies.resize(_size14);
            uint32_t _i18;
            for (_i18 = 0; _i18 < _size14; ++_i18)
            {
              xfer += iprot->readI32(this->dependencies[_i18]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.dependencies = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->dependencies_kind.clear();
            uint32_t _size19;
            ::apache::thrift::protocol::TType _etype22;
            xfer += iprot->readListBegin(_etype22, _size19);
            this->dependencies_kind.resize(_size19);
            uint32_t _i23;
            for (_i23 = 0; _i23 < _size19; ++_i23)
            {
              xfer += iprot->readString(this->dependencies_kind[_i23]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.dependencies_kind = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Unknown::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Unknown");

  xfer += oprot->writeFieldBegin("index", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->index);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dependencies", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->dependencies.size()));
    std::vector<int32_t> ::const_iterator _iter24;
    for (_iter24 = this->dependencies.begin(); _iter24 != this->dependencies.end(); ++_iter24)
    {
      xfer += oprot->writeI32((*_iter24));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dependencies_kind", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->dependencies_kind.size()));
    std::vector<std::string> ::const_iterator _iter25;
    for (_iter25 = this->dependencies_kind.begin(); _iter25 != this->dependencies_kind.end(); ++_iter25)
    {
      xfer += oprot->writeString((*_iter25));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Unknown &a, Unknown &b) {
  using ::std::swap;
  swap(a.index, b.index);
  swap(a.dependencies, b.dependencies);
  swap(a.dependencies_kind, b.dependencies_kind);
  swap(a.__isset, b.__isset);
}

Unknown::Unknown(const Unknown& other26) {
  index = other26.index;
  dependencies = other26.dependencies;
  dependencies_kind = other26.dependencies_kind;
  __isset = other26.__isset;
}
Unknown& Unknown::operator=(const Unknown& other27) {
  index = other27.index;
  dependencies = other27.dependencies;
  dependencies_kind = other27.dependencies_kind;
  __isset = other27.__isset;
  return *this;
}
void Unknown::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Unknown(";
  out << "index=" << to_string(index);
  out << ", " << "dependencies=" << to_string(dependencies);
  out << ", " << "dependencies_kind=" << to_string(dependencies_kind);
  out << ")";
}


ModelStructure::~ModelStructure() throw() {
}


void ModelStructure::__set_outputs(const std::vector<Unknown> & val) {
  this->outputs = val;
}

void ModelStructure::__set_derivatives(const std::vector<Unknown> & val) {
  this->derivatives = val;
}

void ModelStructure::__set_initial_unknowns(const std::vector<Unknown> & val) {
  this->initial_unknowns = val;
}
std::ostream& operator<<(std::ostream& out, const ModelStructure& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ModelStructure::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->outputs.clear();
            uint32_t _size28;
            ::apache::thrift::protocol::TType _etype31;
            xfer += iprot->readListBegin(_etype31, _size28);
            this->outputs.resize(_size28);
            uint32_t _i32;
            for (_i32 = 0; _i32 < _size28; ++_i32)
            {
              xfer += this->outputs[_i32].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.outputs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->derivatives.clear();
            uint32_t _size33;
            ::apache::thrift::protocol::TType _etype36;
            xfer += iprot->readListBegin(_etype36, _size33);
            this->derivatives.resize(_size33);
            uint32_t _i37;
            for (_i37 = 0; _i37 < _size33; ++_i37)
            {
              xfer += this->derivatives[_i37].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.derivatives = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->initial_unknowns.clear();
            uint32_t _size38;
            ::apache::thrift::protocol::TType _etype41;
            xfer += iprot->readListBegin(_etype41, _size38);
            this->initial_unknowns.resize(_size38);
            uint32_t _i42;
            for (_i42 = 0; _i42 < _size38; ++_i42)
            {
              xfer += this->initial_unknowns[_i42].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.initial_unknowns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ModelStructure::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ModelStructure");

  xfer += oprot->writeFieldBegin("outputs", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->outputs.size()));
    std::vector<Unknown> ::const_iterator _iter43;
    for (_iter43 = this->outputs.begin(); _iter43 != this->outputs.end(); ++_iter43)
    {
      xfer += (*_iter43).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("derivatives", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->derivatives.size()));
    std::vector<Unknown> ::const_iterator _iter44;
    for (_iter44 = this->derivatives.begin(); _iter44 != this->derivatives.end(); ++_iter44)
    {
      xfer += (*_iter44).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("initial_unknowns", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->initial_unknowns.size()));
    std::vector<Unknown> ::const_iterator _iter45;
    for (_iter45 = this->initial_unknowns.begin(); _iter45 != this->initial_unknowns.end(); ++_iter45)
    {
      xfer += (*_iter45).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ModelStructure &a, ModelStructure &b) {
  using ::std::swap;
  swap(a.outputs, b.outputs);
  swap(a.derivatives, b.derivatives);
  swap(a.initial_unknowns, b.initial_unknowns);
  swap(a.__isset, b.__isset);
}

ModelStructure::ModelStructure(const ModelStructure& other46) {
  outputs = other46.outputs;
  derivatives = other46.derivatives;
  initial_unknowns = other46.initial_unknowns;
  __isset = other46.__isset;
}
ModelStructure& ModelStructure::operator=(const ModelStructure& other47) {
  outputs = other47.outputs;
  derivatives = other47.derivatives;
  initial_unknowns = other47.initial_unknowns;
  __isset = other47.__isset;
  return *this;
}
void ModelStructure::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ModelStructure(";
  out << "outputs=" << to_string(outputs);
  out << ", " << "derivatives=" << to_string(derivatives);
  out << ", " << "initial_unknowns=" << to_string(initial_unknowns);
  out << ")";
}


DefaultExperiment::~DefaultExperiment() throw() {
}


void DefaultExperiment::__set_startTime(const double val) {
  this->startTime = val;
}

void DefaultExperiment::__set_stopTime(const double val) {
  this->stopTime = val;
}

void DefaultExperiment::__set_tolerance(const double val) {
  this->tolerance = val;
}

void DefaultExperiment::__set_stepSize(const double val) {
  this->stepSize = val;
}
std::ostream& operator<<(std::ostream& out, const DefaultExperiment& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t DefaultExperiment::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->startTime);
          this->__isset.startTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->stopTime);
          this->__isset.stopTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->tolerance);
          this->__isset.tolerance = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->stepSize);
          this->__isset.stepSize = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DefaultExperiment::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DefaultExperiment");

  xfer += oprot->writeFieldBegin("startTime", ::apache::thrift::protocol::T_DOUBLE, 1);
  xfer += oprot->writeDouble(this->startTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("stopTime", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->stopTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tolerance", ::apache::thrift::protocol::T_DOUBLE, 3);
  xfer += oprot->writeDouble(this->tolerance);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("stepSize", ::apache::thrift::protocol::T_DOUBLE, 4);
  xfer += oprot->writeDouble(this->stepSize);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DefaultExperiment &a, DefaultExperiment &b) {
  using ::std::swap;
  swap(a.startTime, b.startTime);
  swap(a.stopTime, b.stopTime);
  swap(a.tolerance, b.tolerance);
  swap(a.stepSize, b.stepSize);
  swap(a.__isset, b.__isset);
}

DefaultExperiment::DefaultExperiment(const DefaultExperiment& other48) {
  startTime = other48.startTime;
  stopTime = other48.stopTime;
  tolerance = other48.tolerance;
  stepSize = other48.stepSize;
  __isset = other48.__isset;
}
DefaultExperiment& DefaultExperiment::operator=(const DefaultExperiment& other49) {
  startTime = other49.startTime;
  stopTime = other49.stopTime;
  tolerance = other49.tolerance;
  stepSize = other49.stepSize;
  __isset = other49.__isset;
  return *this;
}
void DefaultExperiment::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DefaultExperiment(";
  out << "startTime=" << to_string(startTime);
  out << ", " << "stopTime=" << to_string(stopTime);
  out << ", " << "tolerance=" << to_string(tolerance);
  out << ", " << "stepSize=" << to_string(stepSize);
  out << ")";
}


StepResult::~StepResult() throw() {
}


void StepResult::__set_status(const Status::type val) {
  this->status = val;
}

void StepResult::__set_simulation_time(const double val) {
  this->simulation_time = val;
}
std::ostream& operator<<(std::ostream& out, const StepResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t StepResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast50;
          xfer += iprot->readI32(ecast50);
          this->status = (Status::type)ecast50;
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->simulation_time);
          this->__isset.simulation_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t StepResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("StepResult");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("simulation_time", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->simulation_time);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(StepResult &a, StepResult &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.simulation_time, b.simulation_time);
  swap(a.__isset, b.__isset);
}

StepResult::StepResult(const StepResult& other51) {
  status = other51.status;
  simulation_time = other51.simulation_time;
  __isset = other51.__isset;
}
StepResult& StepResult::operator=(const StepResult& other52) {
  status = other52.status;
  simulation_time = other52.simulation_time;
  __isset = other52.__isset;
  return *this;
}
void StepResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "StepResult(";
  out << "status=" << to_string(status);
  out << ", " << "simulation_time=" << to_string(simulation_time);
  out << ")";
}


IntegerRead::~IntegerRead() throw() {
}


void IntegerRead::__set_value(const std::vector<int32_t> & val) {
  this->value = val;
}

void IntegerRead::__set_status(const Status::type val) {
  this->status = val;
}
std::ostream& operator<<(std::ostream& out, const IntegerRead& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t IntegerRead::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->value.clear();
            uint32_t _size53;
            ::apache::thrift::protocol::TType _etype56;
            xfer += iprot->readListBegin(_etype56, _size53);
            this->value.resize(_size53);
            uint32_t _i57;
            for (_i57 = 0; _i57 < _size53; ++_i57)
            {
              xfer += iprot->readI32(this->value[_i57]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast58;
          xfer += iprot->readI32(ecast58);
          this->status = (Status::type)ecast58;
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t IntegerRead::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("IntegerRead");

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->value.size()));
    std::vector<int32_t> ::const_iterator _iter59;
    for (_iter59 = this->value.begin(); _iter59 != this->value.end(); ++_iter59)
    {
      xfer += oprot->writeI32((*_iter59));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(IntegerRead &a, IntegerRead &b) {
  using ::std::swap;
  swap(a.value, b.value);
  swap(a.status, b.status);
  swap(a.__isset, b.__isset);
}

IntegerRead::IntegerRead(const IntegerRead& other60) {
  value = other60.value;
  status = other60.status;
  __isset = other60.__isset;
}
IntegerRead& IntegerRead::operator=(const IntegerRead& other61) {
  value = other61.value;
  status = other61.status;
  __isset = other61.__isset;
  return *this;
}
void IntegerRead::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "IntegerRead(";
  out << "value=" << to_string(value);
  out << ", " << "status=" << to_string(status);
  out << ")";
}


RealRead::~RealRead() throw() {
}


void RealRead::__set_value(const std::vector<double> & val) {
  this->value = val;
}

void RealRead::__set_status(const Status::type val) {
  this->status = val;
}
std::ostream& operator<<(std::ostream& out, const RealRead& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t RealRead::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->value.clear();
            uint32_t _size62;
            ::apache::thrift::protocol::TType _etype65;
            xfer += iprot->readListBegin(_etype65, _size62);
            this->value.resize(_size62);
            uint32_t _i66;
            for (_i66 = 0; _i66 < _size62; ++_i66)
            {
              xfer += iprot->readDouble(this->value[_i66]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast67;
          xfer += iprot->readI32(ecast67);
          this->status = (Status::type)ecast67;
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t RealRead::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("RealRead");

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->value.size()));
    std::vector<double> ::const_iterator _iter68;
    for (_iter68 = this->value.begin(); _iter68 != this->value.end(); ++_iter68)
    {
      xfer += oprot->writeDouble((*_iter68));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RealRead &a, RealRead &b) {
  using ::std::swap;
  swap(a.value, b.value);
  swap(a.status, b.status);
  swap(a.__isset, b.__isset);
}

RealRead::RealRead(const RealRead& other69) {
  value = other69.value;
  status = other69.status;
  __isset = other69.__isset;
}
RealRead& RealRead::operator=(const RealRead& other70) {
  value = other70.value;
  status = other70.status;
  __isset = other70.__isset;
  return *this;
}
void RealRead::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "RealRead(";
  out << "value=" << to_string(value);
  out << ", " << "status=" << to_string(status);
  out << ")";
}


StringRead::~StringRead() throw() {
}


void StringRead::__set_value(const std::vector<std::string> & val) {
  this->value = val;
}

void StringRead::__set_status(const Status::type val) {
  this->status = val;
}
std::ostream& operator<<(std::ostream& out, const StringRead& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t StringRead::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->value.clear();
            uint32_t _size71;
            ::apache::thrift::protocol::TType _etype74;
            xfer += iprot->readListBegin(_etype74, _size71);
            this->value.resize(_size71);
            uint32_t _i75;
            for (_i75 = 0; _i75 < _size71; ++_i75)
            {
              xfer += iprot->readString(this->value[_i75]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast76;
          xfer += iprot->readI32(ecast76);
          this->status = (Status::type)ecast76;
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t StringRead::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("StringRead");

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->value.size()));
    std::vector<std::string> ::const_iterator _iter77;
    for (_iter77 = this->value.begin(); _iter77 != this->value.end(); ++_iter77)
    {
      xfer += oprot->writeString((*_iter77));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(StringRead &a, StringRead &b) {
  using ::std::swap;
  swap(a.value, b.value);
  swap(a.status, b.status);
  swap(a.__isset, b.__isset);
}

StringRead::StringRead(const StringRead& other78) {
  value = other78.value;
  status = other78.status;
  __isset = other78.__isset;
}
StringRead& StringRead::operator=(const StringRead& other79) {
  value = other79.value;
  status = other79.status;
  __isset = other79.__isset;
  return *this;
}
void StringRead::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "StringRead(";
  out << "value=" << to_string(value);
  out << ", " << "status=" << to_string(status);
  out << ")";
}


BooleanRead::~BooleanRead() throw() {
}


void BooleanRead::__set_value(const std::vector<bool> & val) {
  this->value = val;
}

void BooleanRead::__set_status(const Status::type val) {
  this->status = val;
}
std::ostream& operator<<(std::ostream& out, const BooleanRead& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t BooleanRead::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->value.clear();
            uint32_t _size80;
            ::apache::thrift::protocol::TType _etype83;
            xfer += iprot->readListBegin(_etype83, _size80);
            this->value.resize(_size80);
            uint32_t _i84;
            for (_i84 = 0; _i84 < _size80; ++_i84)
            {
              xfer += iprot->readBool(this->value[_i84]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast85;
          xfer += iprot->readI32(ecast85);
          this->status = (Status::type)ecast85;
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BooleanRead::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("BooleanRead");

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_BOOL, static_cast<uint32_t>(this->value.size()));
    std::vector<bool> ::const_iterator _iter86;
    for (_iter86 = this->value.begin(); _iter86 != this->value.end(); ++_iter86)
    {
      xfer += oprot->writeBool((*_iter86));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BooleanRead &a, BooleanRead &b) {
  using ::std::swap;
  swap(a.value, b.value);
  swap(a.status, b.status);
  swap(a.__isset, b.__isset);
}

BooleanRead::BooleanRead(const BooleanRead& other87) {
  value = other87.value;
  status = other87.status;
  __isset = other87.__isset;
}
BooleanRead& BooleanRead::operator=(const BooleanRead& other88) {
  value = other88.value;
  status = other88.status;
  __isset = other88.__isset;
  return *this;
}
void BooleanRead::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "BooleanRead(";
  out << "value=" << to_string(value);
  out << ", " << "status=" << to_string(status);
  out << ")";
}


ModelDescription::~ModelDescription() throw() {
}


void ModelDescription::__set_guid(const std::string& val) {
  this->guid = val;
}

void ModelDescription::__set_fmi_version(const std::string& val) {
  this->fmi_version = val;
}

void ModelDescription::__set_modelName(const std::string& val) {
  this->modelName = val;
}

void ModelDescription::__set_license(const std::string& val) {
  this->license = val;
__isset.license = true;
}

void ModelDescription::__set_copyright(const std::string& val) {
  this->copyright = val;
__isset.copyright = true;
}

void ModelDescription::__set_author(const std::string& val) {
  this->author = val;
__isset.author = true;
}

void ModelDescription::__set_version(const std::string& val) {
  this->version = val;
__isset.version = true;
}

void ModelDescription::__set_description(const std::string& val) {
  this->description = val;
__isset.description = true;
}

void ModelDescription::__set_generation_tool(const std::string& val) {
  this->generation_tool = val;
__isset.generation_tool = true;
}

void ModelDescription::__set_generation_date_and_time(const std::string& val) {
  this->generation_date_and_time = val;
__isset.generation_date_and_time = true;
}

void ModelDescription::__set_default_experiment(const DefaultExperiment& val) {
  this->default_experiment = val;
__isset.default_experiment = true;
}

void ModelDescription::__set_variable_naming_convention(const std::string& val) {
  this->variable_naming_convention = val;
__isset.variable_naming_convention = true;
}

void ModelDescription::__set_model_variables(const ModelVariables& val) {
  this->model_variables = val;
}

void ModelDescription::__set_model_structure(const ModelStructure& val) {
  this->model_structure = val;
}

void ModelDescription::__set_model_identifier(const std::string& val) {
  this->model_identifier = val;
}

void ModelDescription::__set_can_get_and_set_fmu_state(const bool val) {
  this->can_get_and_set_fmu_state = val;
}

void ModelDescription::__set_can_serialize_fmu_state(const bool val) {
  this->can_serialize_fmu_state = val;
}

void ModelDescription::__set_provides_directional_derivative(const bool val) {
  this->provides_directional_derivative = val;
}

void ModelDescription::__set_can_handle_variable_communication_step_size(const bool val) {
  this->can_handle_variable_communication_step_size = val;
}

void ModelDescription::__set_can_interpolate_inputs(const bool val) {
  this->can_interpolate_inputs = val;
}

void ModelDescription::__set_max_output_derivative_order(const int32_t val) {
  this->max_output_derivative_order = val;
}
std::ostream& operator<<(std::ostream& out, const ModelDescription& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ModelDescription::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->guid);
          this->__isset.guid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->fmi_version);
          this->__isset.fmi_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->modelName);
          this->__isset.modelName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->license);
          this->__isset.license = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->copyright);
          this->__isset.copyright = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->author);
          this->__isset.author = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->version);
          this->__isset.version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->description);
          this->__isset.description = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->generation_tool);
          this->__isset.generation_tool = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->generation_date_and_time);
          this->__isset.generation_date_and_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->default_experiment.read(iprot);
          this->__isset.default_experiment = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->variable_naming_convention);
          this->__isset.variable_naming_convention = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->model_variables.clear();
            uint32_t _size89;
            ::apache::thrift::protocol::TType _etype92;
            xfer += iprot->readListBegin(_etype92, _size89);
            this->model_variables.resize(_size89);
            uint32_t _i93;
            for (_i93 = 0; _i93 < _size89; ++_i93)
            {
              xfer += this->model_variables[_i93].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.model_variables = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->model_structure.read(iprot);
          this->__isset.model_structure = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->model_identifier);
          this->__isset.model_identifier = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->can_get_and_set_fmu_state);
          this->__isset.can_get_and_set_fmu_state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->can_serialize_fmu_state);
          this->__isset.can_serialize_fmu_state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->provides_directional_derivative);
          this->__isset.provides_directional_derivative = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->can_handle_variable_communication_step_size);
          this->__isset.can_handle_variable_communication_step_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->can_interpolate_inputs);
          this->__isset.can_interpolate_inputs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->max_output_derivative_order);
          this->__isset.max_output_derivative_order = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ModelDescription::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ModelDescription");

  xfer += oprot->writeFieldBegin("guid", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->guid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fmi_version", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->fmi_version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("modelName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->modelName);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.license) {
    xfer += oprot->writeFieldBegin("license", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->license);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.copyright) {
    xfer += oprot->writeFieldBegin("copyright", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->copyright);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.author) {
    xfer += oprot->writeFieldBegin("author", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->author);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.version) {
    xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->version);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.description) {
    xfer += oprot->writeFieldBegin("description", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->description);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.generation_tool) {
    xfer += oprot->writeFieldBegin("generation_tool", ::apache::thrift::protocol::T_STRING, 9);
    xfer += oprot->writeString(this->generation_tool);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.generation_date_and_time) {
    xfer += oprot->writeFieldBegin("generation_date_and_time", ::apache::thrift::protocol::T_STRING, 10);
    xfer += oprot->writeString(this->generation_date_and_time);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.default_experiment) {
    xfer += oprot->writeFieldBegin("default_experiment", ::apache::thrift::protocol::T_STRUCT, 11);
    xfer += this->default_experiment.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.variable_naming_convention) {
    xfer += oprot->writeFieldBegin("variable_naming_convention", ::apache::thrift::protocol::T_STRING, 12);
    xfer += oprot->writeString(this->variable_naming_convention);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("model_variables", ::apache::thrift::protocol::T_LIST, 13);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->model_variables.size()));
    std::vector<ScalarVariable> ::const_iterator _iter94;
    for (_iter94 = this->model_variables.begin(); _iter94 != this->model_variables.end(); ++_iter94)
    {
      xfer += (*_iter94).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("model_structure", ::apache::thrift::protocol::T_STRUCT, 14);
  xfer += this->model_structure.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("model_identifier", ::apache::thrift::protocol::T_STRING, 15);
  xfer += oprot->writeString(this->model_identifier);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("can_get_and_set_fmu_state", ::apache::thrift::protocol::T_BOOL, 16);
  xfer += oprot->writeBool(this->can_get_and_set_fmu_state);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("can_serialize_fmu_state", ::apache::thrift::protocol::T_BOOL, 17);
  xfer += oprot->writeBool(this->can_serialize_fmu_state);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("provides_directional_derivative", ::apache::thrift::protocol::T_BOOL, 18);
  xfer += oprot->writeBool(this->provides_directional_derivative);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("can_handle_variable_communication_step_size", ::apache::thrift::protocol::T_BOOL, 19);
  xfer += oprot->writeBool(this->can_handle_variable_communication_step_size);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("can_interpolate_inputs", ::apache::thrift::protocol::T_BOOL, 20);
  xfer += oprot->writeBool(this->can_interpolate_inputs);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("max_output_derivative_order", ::apache::thrift::protocol::T_I32, 21);
  xfer += oprot->writeI32(this->max_output_derivative_order);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ModelDescription &a, ModelDescription &b) {
  using ::std::swap;
  swap(a.guid, b.guid);
  swap(a.fmi_version, b.fmi_version);
  swap(a.modelName, b.modelName);
  swap(a.license, b.license);
  swap(a.copyright, b.copyright);
  swap(a.author, b.author);
  swap(a.version, b.version);
  swap(a.description, b.description);
  swap(a.generation_tool, b.generation_tool);
  swap(a.generation_date_and_time, b.generation_date_and_time);
  swap(a.default_experiment, b.default_experiment);
  swap(a.variable_naming_convention, b.variable_naming_convention);
  swap(a.model_variables, b.model_variables);
  swap(a.model_structure, b.model_structure);
  swap(a.model_identifier, b.model_identifier);
  swap(a.can_get_and_set_fmu_state, b.can_get_and_set_fmu_state);
  swap(a.can_serialize_fmu_state, b.can_serialize_fmu_state);
  swap(a.provides_directional_derivative, b.provides_directional_derivative);
  swap(a.can_handle_variable_communication_step_size, b.can_handle_variable_communication_step_size);
  swap(a.can_interpolate_inputs, b.can_interpolate_inputs);
  swap(a.max_output_derivative_order, b.max_output_derivative_order);
  swap(a.__isset, b.__isset);
}

ModelDescription::ModelDescription(const ModelDescription& other95) {
  guid = other95.guid;
  fmi_version = other95.fmi_version;
  modelName = other95.modelName;
  license = other95.license;
  copyright = other95.copyright;
  author = other95.author;
  version = other95.version;
  description = other95.description;
  generation_tool = other95.generation_tool;
  generation_date_and_time = other95.generation_date_and_time;
  default_experiment = other95.default_experiment;
  variable_naming_convention = other95.variable_naming_convention;
  model_variables = other95.model_variables;
  model_structure = other95.model_structure;
  model_identifier = other95.model_identifier;
  can_get_and_set_fmu_state = other95.can_get_and_set_fmu_state;
  can_serialize_fmu_state = other95.can_serialize_fmu_state;
  provides_directional_derivative = other95.provides_directional_derivative;
  can_handle_variable_communication_step_size = other95.can_handle_variable_communication_step_size;
  can_interpolate_inputs = other95.can_interpolate_inputs;
  max_output_derivative_order = other95.max_output_derivative_order;
  __isset = other95.__isset;
}
ModelDescription& ModelDescription::operator=(const ModelDescription& other96) {
  guid = other96.guid;
  fmi_version = other96.fmi_version;
  modelName = other96.modelName;
  license = other96.license;
  copyright = other96.copyright;
  author = other96.author;
  version = other96.version;
  description = other96.description;
  generation_tool = other96.generation_tool;
  generation_date_and_time = other96.generation_date_and_time;
  default_experiment = other96.default_experiment;
  variable_naming_convention = other96.variable_naming_convention;
  model_variables = other96.model_variables;
  model_structure = other96.model_structure;
  model_identifier = other96.model_identifier;
  can_get_and_set_fmu_state = other96.can_get_and_set_fmu_state;
  can_serialize_fmu_state = other96.can_serialize_fmu_state;
  provides_directional_derivative = other96.provides_directional_derivative;
  can_handle_variable_communication_step_size = other96.can_handle_variable_communication_step_size;
  can_interpolate_inputs = other96.can_interpolate_inputs;
  max_output_derivative_order = other96.max_output_derivative_order;
  __isset = other96.__isset;
  return *this;
}
void ModelDescription::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ModelDescription(";
  out << "guid=" << to_string(guid);
  out << ", " << "fmi_version=" << to_string(fmi_version);
  out << ", " << "modelName=" << to_string(modelName);
  out << ", " << "license="; (__isset.license ? (out << to_string(license)) : (out << "<null>"));
  out << ", " << "copyright="; (__isset.copyright ? (out << to_string(copyright)) : (out << "<null>"));
  out << ", " << "author="; (__isset.author ? (out << to_string(author)) : (out << "<null>"));
  out << ", " << "version="; (__isset.version ? (out << to_string(version)) : (out << "<null>"));
  out << ", " << "description="; (__isset.description ? (out << to_string(description)) : (out << "<null>"));
  out << ", " << "generation_tool="; (__isset.generation_tool ? (out << to_string(generation_tool)) : (out << "<null>"));
  out << ", " << "generation_date_and_time="; (__isset.generation_date_and_time ? (out << to_string(generation_date_and_time)) : (out << "<null>"));
  out << ", " << "default_experiment="; (__isset.default_experiment ? (out << to_string(default_experiment)) : (out << "<null>"));
  out << ", " << "variable_naming_convention="; (__isset.variable_naming_convention ? (out << to_string(variable_naming_convention)) : (out << "<null>"));
  out << ", " << "model_variables=" << to_string(model_variables);
  out << ", " << "model_structure=" << to_string(model_structure);
  out << ", " << "model_identifier=" << to_string(model_identifier);
  out << ", " << "can_get_and_set_fmu_state=" << to_string(can_get_and_set_fmu_state);
  out << ", " << "can_serialize_fmu_state=" << to_string(can_serialize_fmu_state);
  out << ", " << "provides_directional_derivative=" << to_string(provides_directional_derivative);
  out << ", " << "can_handle_variable_communication_step_size=" << to_string(can_handle_variable_communication_step_size);
  out << ", " << "can_interpolate_inputs=" << to_string(can_interpolate_inputs);
  out << ", " << "max_output_derivative_order=" << to_string(max_output_derivative_order);
  out << ")";
}


NoSuchFmuException::~NoSuchFmuException() throw() {
}


void NoSuchFmuException::__set_message(const std::string& val) {
  this->message = val;
}
std::ostream& operator<<(std::ostream& out, const NoSuchFmuException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t NoSuchFmuException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoSuchFmuException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoSuchFmuException");

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NoSuchFmuException &a, NoSuchFmuException &b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

NoSuchFmuException::NoSuchFmuException(const NoSuchFmuException& other97) : TException() {
  message = other97.message;
  __isset = other97.__isset;
}
NoSuchFmuException& NoSuchFmuException::operator=(const NoSuchFmuException& other98) {
  message = other98.message;
  __isset = other98.__isset;
  return *this;
}
void NoSuchFmuException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "NoSuchFmuException(";
  out << "message=" << to_string(message);
  out << ")";
}

const char* NoSuchFmuException::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: NoSuchFmuException";
  }
}


NoSuchInstanceException::~NoSuchInstanceException() throw() {
}


void NoSuchInstanceException::__set_message(const std::string& val) {
  this->message = val;
}
std::ostream& operator<<(std::ostream& out, const NoSuchInstanceException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t NoSuchInstanceException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoSuchInstanceException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoSuchInstanceException");

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NoSuchInstanceException &a, NoSuchInstanceException &b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

NoSuchInstanceException::NoSuchInstanceException(const NoSuchInstanceException& other99) : TException() {
  message = other99.message;
  __isset = other99.__isset;
}
NoSuchInstanceException& NoSuchInstanceException::operator=(const NoSuchInstanceException& other100) {
  message = other100.message;
  __isset = other100.__isset;
  return *this;
}
void NoSuchInstanceException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "NoSuchInstanceException(";
  out << "message=" << to_string(message);
  out << ")";
}

const char* NoSuchInstanceException::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: NoSuchInstanceException";
  }
}


NoSuchVariableException::~NoSuchVariableException() throw() {
}


void NoSuchVariableException::__set_message(const std::string& val) {
  this->message = val;
}
std::ostream& operator<<(std::ostream& out, const NoSuchVariableException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t NoSuchVariableException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoSuchVariableException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoSuchVariableException");

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NoSuchVariableException &a, NoSuchVariableException &b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

NoSuchVariableException::NoSuchVariableException(const NoSuchVariableException& other101) : TException() {
  message = other101.message;
  __isset = other101.__isset;
}
NoSuchVariableException& NoSuchVariableException::operator=(const NoSuchVariableException& other102) {
  message = other102.message;
  __isset = other102.__isset;
  return *this;
}
void NoSuchVariableException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "NoSuchVariableException(";
  out << "message=" << to_string(message);
  out << ")";
}

const char* NoSuchVariableException::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: NoSuchVariableException";
  }
}


UnsupportedOperationException::~UnsupportedOperationException() throw() {
}


void UnsupportedOperationException::__set_message(const std::string& val) {
  this->message = val;
}
std::ostream& operator<<(std::ostream& out, const UnsupportedOperationException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t UnsupportedOperationException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t UnsupportedOperationException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("UnsupportedOperationException");

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UnsupportedOperationException &a, UnsupportedOperationException &b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

UnsupportedOperationException::UnsupportedOperationException(const UnsupportedOperationException& other103) : TException() {
  message = other103.message;
  __isset = other103.__isset;
}
UnsupportedOperationException& UnsupportedOperationException::operator=(const UnsupportedOperationException& other104) {
  message = other104.message;
  __isset = other104.__isset;
  return *this;
}
void UnsupportedOperationException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "UnsupportedOperationException(";
  out << "message=" << to_string(message);
  out << ")";
}

const char* UnsupportedOperationException::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: UnsupportedOperationException";
  }
}


DirectionalDerivativeResult::~DirectionalDerivativeResult() throw() {
}


void DirectionalDerivativeResult::__set_dv_unknown_ref(const DirectionalDerivative& val) {
  this->dv_unknown_ref = val;
}

void DirectionalDerivativeResult::__set_status(const Status::type val) {
  this->status = val;
}
std::ostream& operator<<(std::ostream& out, const DirectionalDerivativeResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t DirectionalDerivativeResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->dv_unknown_ref.clear();
            uint32_t _size105;
            ::apache::thrift::protocol::TType _etype108;
            xfer += iprot->readListBegin(_etype108, _size105);
            this->dv_unknown_ref.resize(_size105);
            uint32_t _i109;
            for (_i109 = 0; _i109 < _size105; ++_i109)
            {
              xfer += iprot->readDouble(this->dv_unknown_ref[_i109]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.dv_unknown_ref = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast110;
          xfer += iprot->readI32(ecast110);
          this->status = (Status::type)ecast110;
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DirectionalDerivativeResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DirectionalDerivativeResult");

  xfer += oprot->writeFieldBegin("dv_unknown_ref", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->dv_unknown_ref.size()));
    std::vector<double> ::const_iterator _iter111;
    for (_iter111 = this->dv_unknown_ref.begin(); _iter111 != this->dv_unknown_ref.end(); ++_iter111)
    {
      xfer += oprot->writeDouble((*_iter111));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DirectionalDerivativeResult &a, DirectionalDerivativeResult &b) {
  using ::std::swap;
  swap(a.dv_unknown_ref, b.dv_unknown_ref);
  swap(a.status, b.status);
  swap(a.__isset, b.__isset);
}

DirectionalDerivativeResult::DirectionalDerivativeResult(const DirectionalDerivativeResult& other112) {
  dv_unknown_ref = other112.dv_unknown_ref;
  status = other112.status;
  __isset = other112.__isset;
}
DirectionalDerivativeResult& DirectionalDerivativeResult::operator=(const DirectionalDerivativeResult& other113) {
  dv_unknown_ref = other113.dv_unknown_ref;
  status = other113.status;
  __isset = other113.__isset;
  return *this;
}
void DirectionalDerivativeResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DirectionalDerivativeResult(";
  out << "dv_unknown_ref=" << to_string(dv_unknown_ref);
  out << ", " << "status=" << to_string(status);
  out << ")";
}

}} // namespace
