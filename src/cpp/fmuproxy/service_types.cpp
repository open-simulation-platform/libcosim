/**
 * Autogenerated by Thrift Compiler (1.0.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include <cse/fmuproxy/service_types.hpp>

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace fmuproxy { namespace thrift {

int _kStatusValues[] = {
  Status::OK_STATUS,
  Status::WARNING_STATUS,
  Status::DISCARD_STATUS,
  Status::ERROR_STATUS,
  Status::FATAL_STATUS,
  Status::PENDING_STATUS
};
const char* _kStatusNames[] = {
  "OK_STATUS",
  "WARNING_STATUS",
  "DISCARD_STATUS",
  "ERROR_STATUS",
  "FATAL_STATUS",
  "PENDING_STATUS"
};
const std::map<int, const char*> _Status_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _kStatusValues, _kStatusNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const Status::type& val) {
  std::map<int, const char*>::const_iterator it = _Status_VALUES_TO_NAMES.find(val);
  if (it != _Status_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}


IntegerAttribute::~IntegerAttribute() noexcept {
}


void IntegerAttribute::__set_min(const int32_t val) {
  this->min = val;
}

void IntegerAttribute::__set_max(const int32_t val) {
  this->max = val;
}

void IntegerAttribute::__set_start(const int32_t val) {
  this->start = val;
}

void IntegerAttribute::__set_quantity(const std::string& val) {
  this->quantity = val;
}
std::ostream& operator<<(std::ostream& out, const IntegerAttribute& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t IntegerAttribute::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->min);
          this->__isset.min = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->max);
          this->__isset.max = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->start);
          this->__isset.start = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->quantity);
          this->__isset.quantity = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t IntegerAttribute::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("IntegerAttribute");

  xfer += oprot->writeFieldBegin("min", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->min);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("max", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->max);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("start", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->start);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("quantity", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->quantity);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(IntegerAttribute &a, IntegerAttribute &b) {
  using ::std::swap;
  swap(a.min, b.min);
  swap(a.max, b.max);
  swap(a.start, b.start);
  swap(a.quantity, b.quantity);
  swap(a.__isset, b.__isset);
}

IntegerAttribute::IntegerAttribute(const IntegerAttribute& other0) {
  min = other0.min;
  max = other0.max;
  start = other0.start;
  quantity = other0.quantity;
  __isset = other0.__isset;
}
IntegerAttribute& IntegerAttribute::operator=(const IntegerAttribute& other1) {
  min = other1.min;
  max = other1.max;
  start = other1.start;
  quantity = other1.quantity;
  __isset = other1.__isset;
  return *this;
}
void IntegerAttribute::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "IntegerAttribute(";
  out << "min=" << to_string(min);
  out << ", " << "max=" << to_string(max);
  out << ", " << "start=" << to_string(start);
  out << ", " << "quantity=" << to_string(quantity);
  out << ")";
}


RealAttribute::~RealAttribute() noexcept {
}


void RealAttribute::__set_min(const double val) {
  this->min = val;
}

void RealAttribute::__set_max(const double val) {
  this->max = val;
}

void RealAttribute::__set_start(const double val) {
  this->start = val;
}

void RealAttribute::__set_quantity(const std::string& val) {
  this->quantity = val;
}
std::ostream& operator<<(std::ostream& out, const RealAttribute& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t RealAttribute::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->min);
          this->__isset.min = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->max);
          this->__isset.max = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->start);
          this->__isset.start = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->quantity);
          this->__isset.quantity = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t RealAttribute::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("RealAttribute");

  xfer += oprot->writeFieldBegin("min", ::apache::thrift::protocol::T_DOUBLE, 1);
  xfer += oprot->writeDouble(this->min);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("max", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->max);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("start", ::apache::thrift::protocol::T_DOUBLE, 3);
  xfer += oprot->writeDouble(this->start);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("quantity", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->quantity);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RealAttribute &a, RealAttribute &b) {
  using ::std::swap;
  swap(a.min, b.min);
  swap(a.max, b.max);
  swap(a.start, b.start);
  swap(a.quantity, b.quantity);
  swap(a.__isset, b.__isset);
}

RealAttribute::RealAttribute(const RealAttribute& other2) {
  min = other2.min;
  max = other2.max;
  start = other2.start;
  quantity = other2.quantity;
  __isset = other2.__isset;
}
RealAttribute& RealAttribute::operator=(const RealAttribute& other3) {
  min = other3.min;
  max = other3.max;
  start = other3.start;
  quantity = other3.quantity;
  __isset = other3.__isset;
  return *this;
}
void RealAttribute::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "RealAttribute(";
  out << "min=" << to_string(min);
  out << ", " << "max=" << to_string(max);
  out << ", " << "start=" << to_string(start);
  out << ", " << "quantity=" << to_string(quantity);
  out << ")";
}


StringAttribute::~StringAttribute() noexcept {
}


void StringAttribute::__set_start(const std::string& val) {
  this->start = val;
}
std::ostream& operator<<(std::ostream& out, const StringAttribute& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t StringAttribute::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->start);
          this->__isset.start = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t StringAttribute::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("StringAttribute");

  xfer += oprot->writeFieldBegin("start", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->start);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(StringAttribute &a, StringAttribute &b) {
  using ::std::swap;
  swap(a.start, b.start);
  swap(a.__isset, b.__isset);
}

StringAttribute::StringAttribute(const StringAttribute& other4) {
  start = other4.start;
  __isset = other4.__isset;
}
StringAttribute& StringAttribute::operator=(const StringAttribute& other5) {
  start = other5.start;
  __isset = other5.__isset;
  return *this;
}
void StringAttribute::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "StringAttribute(";
  out << "start=" << to_string(start);
  out << ")";
}


BooleanAttribute::~BooleanAttribute() noexcept {
}


void BooleanAttribute::__set_start(const bool val) {
  this->start = val;
}
std::ostream& operator<<(std::ostream& out, const BooleanAttribute& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t BooleanAttribute::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->start);
          this->__isset.start = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BooleanAttribute::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("BooleanAttribute");

  xfer += oprot->writeFieldBegin("start", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->start);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BooleanAttribute &a, BooleanAttribute &b) {
  using ::std::swap;
  swap(a.start, b.start);
  swap(a.__isset, b.__isset);
}

BooleanAttribute::BooleanAttribute(const BooleanAttribute& other6) {
  start = other6.start;
  __isset = other6.__isset;
}
BooleanAttribute& BooleanAttribute::operator=(const BooleanAttribute& other7) {
  start = other7.start;
  __isset = other7.__isset;
  return *this;
}
void BooleanAttribute::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "BooleanAttribute(";
  out << "start=" << to_string(start);
  out << ")";
}


EnumerationAttribute::~EnumerationAttribute() noexcept {
}


void EnumerationAttribute::__set_min(const int32_t val) {
  this->min = val;
}

void EnumerationAttribute::__set_max(const int32_t val) {
  this->max = val;
}

void EnumerationAttribute::__set_start(const int32_t val) {
  this->start = val;
}

void EnumerationAttribute::__set_quantity(const std::string& val) {
  this->quantity = val;
}
std::ostream& operator<<(std::ostream& out, const EnumerationAttribute& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t EnumerationAttribute::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->min);
          this->__isset.min = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->max);
          this->__isset.max = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->start);
          this->__isset.start = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->quantity);
          this->__isset.quantity = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t EnumerationAttribute::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("EnumerationAttribute");

  xfer += oprot->writeFieldBegin("min", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->min);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("max", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->max);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("start", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->start);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("quantity", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->quantity);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(EnumerationAttribute &a, EnumerationAttribute &b) {
  using ::std::swap;
  swap(a.min, b.min);
  swap(a.max, b.max);
  swap(a.start, b.start);
  swap(a.quantity, b.quantity);
  swap(a.__isset, b.__isset);
}

EnumerationAttribute::EnumerationAttribute(const EnumerationAttribute& other8) {
  min = other8.min;
  max = other8.max;
  start = other8.start;
  quantity = other8.quantity;
  __isset = other8.__isset;
}
EnumerationAttribute& EnumerationAttribute::operator=(const EnumerationAttribute& other9) {
  min = other9.min;
  max = other9.max;
  start = other9.start;
  quantity = other9.quantity;
  __isset = other9.__isset;
  return *this;
}
void EnumerationAttribute::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "EnumerationAttribute(";
  out << "min=" << to_string(min);
  out << ", " << "max=" << to_string(max);
  out << ", " << "start=" << to_string(start);
  out << ", " << "quantity=" << to_string(quantity);
  out << ")";
}


ScalarVariableAttribute::~ScalarVariableAttribute() noexcept {
}


void ScalarVariableAttribute::__set_integerAttribute(const IntegerAttribute& val) {
  this->integerAttribute = val;
__isset.integerAttribute = true;
}

void ScalarVariableAttribute::__set_realAttribute(const RealAttribute& val) {
  this->realAttribute = val;
__isset.realAttribute = true;
}

void ScalarVariableAttribute::__set_stringAttribute(const StringAttribute& val) {
  this->stringAttribute = val;
__isset.stringAttribute = true;
}

void ScalarVariableAttribute::__set_booleanAttribute(const BooleanAttribute& val) {
  this->booleanAttribute = val;
__isset.booleanAttribute = true;
}

void ScalarVariableAttribute::__set_enumerationAttribute(const EnumerationAttribute& val) {
  this->enumerationAttribute = val;
__isset.enumerationAttribute = true;
}
std::ostream& operator<<(std::ostream& out, const ScalarVariableAttribute& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ScalarVariableAttribute::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->integerAttribute.read(iprot);
          this->__isset.integerAttribute = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->realAttribute.read(iprot);
          this->__isset.realAttribute = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->stringAttribute.read(iprot);
          this->__isset.stringAttribute = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->booleanAttribute.read(iprot);
          this->__isset.booleanAttribute = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->enumerationAttribute.read(iprot);
          this->__isset.enumerationAttribute = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ScalarVariableAttribute::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ScalarVariableAttribute");

  if (this->__isset.integerAttribute) {
    xfer += oprot->writeFieldBegin("integerAttribute", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->integerAttribute.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.realAttribute) {
    xfer += oprot->writeFieldBegin("realAttribute", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->realAttribute.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.stringAttribute) {
    xfer += oprot->writeFieldBegin("stringAttribute", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->stringAttribute.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.booleanAttribute) {
    xfer += oprot->writeFieldBegin("booleanAttribute", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->booleanAttribute.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.enumerationAttribute) {
    xfer += oprot->writeFieldBegin("enumerationAttribute", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->enumerationAttribute.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ScalarVariableAttribute &a, ScalarVariableAttribute &b) {
  using ::std::swap;
  swap(a.integerAttribute, b.integerAttribute);
  swap(a.realAttribute, b.realAttribute);
  swap(a.stringAttribute, b.stringAttribute);
  swap(a.booleanAttribute, b.booleanAttribute);
  swap(a.enumerationAttribute, b.enumerationAttribute);
  swap(a.__isset, b.__isset);
}

ScalarVariableAttribute::ScalarVariableAttribute(const ScalarVariableAttribute& other10) {
  integerAttribute = other10.integerAttribute;
  realAttribute = other10.realAttribute;
  stringAttribute = other10.stringAttribute;
  booleanAttribute = other10.booleanAttribute;
  enumerationAttribute = other10.enumerationAttribute;
  __isset = other10.__isset;
}
ScalarVariableAttribute& ScalarVariableAttribute::operator=(const ScalarVariableAttribute& other11) {
  integerAttribute = other11.integerAttribute;
  realAttribute = other11.realAttribute;
  stringAttribute = other11.stringAttribute;
  booleanAttribute = other11.booleanAttribute;
  enumerationAttribute = other11.enumerationAttribute;
  __isset = other11.__isset;
  return *this;
}
void ScalarVariableAttribute::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ScalarVariableAttribute(";
  out << "integerAttribute="; (__isset.integerAttribute ? (out << to_string(integerAttribute)) : (out << "<null>"));
  out << ", " << "realAttribute="; (__isset.realAttribute ? (out << to_string(realAttribute)) : (out << "<null>"));
  out << ", " << "stringAttribute="; (__isset.stringAttribute ? (out << to_string(stringAttribute)) : (out << "<null>"));
  out << ", " << "booleanAttribute="; (__isset.booleanAttribute ? (out << to_string(booleanAttribute)) : (out << "<null>"));
  out << ", " << "enumerationAttribute="; (__isset.enumerationAttribute ? (out << to_string(enumerationAttribute)) : (out << "<null>"));
  out << ")";
}


ScalarVariable::~ScalarVariable() noexcept {
}


void ScalarVariable::__set_name(const std::string& val) {
  this->name = val;
}

void ScalarVariable::__set_valueReference(const ValueReference val) {
  this->valueReference = val;
}

void ScalarVariable::__set_description(const std::string& val) {
  this->description = val;
__isset.description = true;
}

void ScalarVariable::__set_initial(const std::string& val) {
  this->initial = val;
__isset.initial = true;
}

void ScalarVariable::__set_causality(const std::string& val) {
  this->causality = val;
__isset.causality = true;
}

void ScalarVariable::__set_variability(const std::string& val) {
  this->variability = val;
__isset.variability = true;
}

void ScalarVariable::__set_attribute(const ScalarVariableAttribute& val) {
  this->attribute = val;
}
std::ostream& operator<<(std::ostream& out, const ScalarVariable& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ScalarVariable::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->valueReference);
          this->__isset.valueReference = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->description);
          this->__isset.description = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->initial);
          this->__isset.initial = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->causality);
          this->__isset.causality = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->variability);
          this->__isset.variability = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->attribute.read(iprot);
          this->__isset.attribute = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ScalarVariable::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ScalarVariable");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("valueReference", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->valueReference);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.description) {
    xfer += oprot->writeFieldBegin("description", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->description);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.initial) {
    xfer += oprot->writeFieldBegin("initial", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->initial);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.causality) {
    xfer += oprot->writeFieldBegin("causality", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->causality);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.variability) {
    xfer += oprot->writeFieldBegin("variability", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->variability);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("attribute", ::apache::thrift::protocol::T_STRUCT, 7);
  xfer += this->attribute.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ScalarVariable &a, ScalarVariable &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.valueReference, b.valueReference);
  swap(a.description, b.description);
  swap(a.initial, b.initial);
  swap(a.causality, b.causality);
  swap(a.variability, b.variability);
  swap(a.attribute, b.attribute);
  swap(a.__isset, b.__isset);
}

ScalarVariable::ScalarVariable(const ScalarVariable& other12) {
  name = other12.name;
  valueReference = other12.valueReference;
  description = other12.description;
  initial = other12.initial;
  causality = other12.causality;
  variability = other12.variability;
  attribute = other12.attribute;
  __isset = other12.__isset;
}
ScalarVariable& ScalarVariable::operator=(const ScalarVariable& other13) {
  name = other13.name;
  valueReference = other13.valueReference;
  description = other13.description;
  initial = other13.initial;
  causality = other13.causality;
  variability = other13.variability;
  attribute = other13.attribute;
  __isset = other13.__isset;
  return *this;
}
void ScalarVariable::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ScalarVariable(";
  out << "name=" << to_string(name);
  out << ", " << "valueReference=" << to_string(valueReference);
  out << ", " << "description="; (__isset.description ? (out << to_string(description)) : (out << "<null>"));
  out << ", " << "initial="; (__isset.initial ? (out << to_string(initial)) : (out << "<null>"));
  out << ", " << "causality="; (__isset.causality ? (out << to_string(causality)) : (out << "<null>"));
  out << ", " << "variability="; (__isset.variability ? (out << to_string(variability)) : (out << "<null>"));
  out << ", " << "attribute=" << to_string(attribute);
  out << ")";
}


Unknown::~Unknown() noexcept {
}


void Unknown::__set_index(const int32_t val) {
  this->index = val;
}

void Unknown::__set_dependencies(const std::vector<int32_t> & val) {
  this->dependencies = val;
}

void Unknown::__set_dependenciesKind(const std::vector<std::string> & val) {
  this->dependenciesKind = val;
}
std::ostream& operator<<(std::ostream& out, const Unknown& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Unknown::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->index);
          this->__isset.index = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->dependencies.clear();
            uint32_t _size14;
            ::apache::thrift::protocol::TType _etype17;
            xfer += iprot->readListBegin(_etype17, _size14);
            this->dependencies.resize(_size14);
            uint32_t _i18;
            for (_i18 = 0; _i18 < _size14; ++_i18)
            {
              xfer += iprot->readI32(this->dependencies[_i18]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.dependencies = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->dependenciesKind.clear();
            uint32_t _size19;
            ::apache::thrift::protocol::TType _etype22;
            xfer += iprot->readListBegin(_etype22, _size19);
            this->dependenciesKind.resize(_size19);
            uint32_t _i23;
            for (_i23 = 0; _i23 < _size19; ++_i23)
            {
              xfer += iprot->readString(this->dependenciesKind[_i23]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.dependenciesKind = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Unknown::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Unknown");

  xfer += oprot->writeFieldBegin("index", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->index);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dependencies", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->dependencies.size()));
    std::vector<int32_t> ::const_iterator _iter24;
    for (_iter24 = this->dependencies.begin(); _iter24 != this->dependencies.end(); ++_iter24)
    {
      xfer += oprot->writeI32((*_iter24));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dependenciesKind", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->dependenciesKind.size()));
    std::vector<std::string> ::const_iterator _iter25;
    for (_iter25 = this->dependenciesKind.begin(); _iter25 != this->dependenciesKind.end(); ++_iter25)
    {
      xfer += oprot->writeString((*_iter25));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Unknown &a, Unknown &b) {
  using ::std::swap;
  swap(a.index, b.index);
  swap(a.dependencies, b.dependencies);
  swap(a.dependenciesKind, b.dependenciesKind);
  swap(a.__isset, b.__isset);
}

Unknown::Unknown(const Unknown& other26) {
  index = other26.index;
  dependencies = other26.dependencies;
  dependenciesKind = other26.dependenciesKind;
  __isset = other26.__isset;
}
Unknown& Unknown::operator=(const Unknown& other27) {
  index = other27.index;
  dependencies = other27.dependencies;
  dependenciesKind = other27.dependenciesKind;
  __isset = other27.__isset;
  return *this;
}
void Unknown::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Unknown(";
  out << "index=" << to_string(index);
  out << ", " << "dependencies=" << to_string(dependencies);
  out << ", " << "dependenciesKind=" << to_string(dependenciesKind);
  out << ")";
}


ModelStructure::~ModelStructure() noexcept {
}


void ModelStructure::__set_outputs(const std::vector<Unknown> & val) {
  this->outputs = val;
}

void ModelStructure::__set_derivatives(const std::vector<Unknown> & val) {
  this->derivatives = val;
}

void ModelStructure::__set_initialUnknowns(const std::vector<Unknown> & val) {
  this->initialUnknowns = val;
}
std::ostream& operator<<(std::ostream& out, const ModelStructure& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ModelStructure::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->outputs.clear();
            uint32_t _size28;
            ::apache::thrift::protocol::TType _etype31;
            xfer += iprot->readListBegin(_etype31, _size28);
            this->outputs.resize(_size28);
            uint32_t _i32;
            for (_i32 = 0; _i32 < _size28; ++_i32)
            {
              xfer += this->outputs[_i32].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.outputs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->derivatives.clear();
            uint32_t _size33;
            ::apache::thrift::protocol::TType _etype36;
            xfer += iprot->readListBegin(_etype36, _size33);
            this->derivatives.resize(_size33);
            uint32_t _i37;
            for (_i37 = 0; _i37 < _size33; ++_i37)
            {
              xfer += this->derivatives[_i37].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.derivatives = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->initialUnknowns.clear();
            uint32_t _size38;
            ::apache::thrift::protocol::TType _etype41;
            xfer += iprot->readListBegin(_etype41, _size38);
            this->initialUnknowns.resize(_size38);
            uint32_t _i42;
            for (_i42 = 0; _i42 < _size38; ++_i42)
            {
              xfer += this->initialUnknowns[_i42].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.initialUnknowns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ModelStructure::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ModelStructure");

  xfer += oprot->writeFieldBegin("outputs", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->outputs.size()));
    std::vector<Unknown> ::const_iterator _iter43;
    for (_iter43 = this->outputs.begin(); _iter43 != this->outputs.end(); ++_iter43)
    {
      xfer += (*_iter43).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("derivatives", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->derivatives.size()));
    std::vector<Unknown> ::const_iterator _iter44;
    for (_iter44 = this->derivatives.begin(); _iter44 != this->derivatives.end(); ++_iter44)
    {
      xfer += (*_iter44).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("initialUnknowns", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->initialUnknowns.size()));
    std::vector<Unknown> ::const_iterator _iter45;
    for (_iter45 = this->initialUnknowns.begin(); _iter45 != this->initialUnknowns.end(); ++_iter45)
    {
      xfer += (*_iter45).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ModelStructure &a, ModelStructure &b) {
  using ::std::swap;
  swap(a.outputs, b.outputs);
  swap(a.derivatives, b.derivatives);
  swap(a.initialUnknowns, b.initialUnknowns);
  swap(a.__isset, b.__isset);
}

ModelStructure::ModelStructure(const ModelStructure& other46) {
  outputs = other46.outputs;
  derivatives = other46.derivatives;
  initialUnknowns = other46.initialUnknowns;
  __isset = other46.__isset;
}
ModelStructure& ModelStructure::operator=(const ModelStructure& other47) {
  outputs = other47.outputs;
  derivatives = other47.derivatives;
  initialUnknowns = other47.initialUnknowns;
  __isset = other47.__isset;
  return *this;
}
void ModelStructure::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ModelStructure(";
  out << "outputs=" << to_string(outputs);
  out << ", " << "derivatives=" << to_string(derivatives);
  out << ", " << "initialUnknowns=" << to_string(initialUnknowns);
  out << ")";
}


DefaultExperiment::~DefaultExperiment() noexcept {
}


void DefaultExperiment::__set_startTime(const double val) {
  this->startTime = val;
}

void DefaultExperiment::__set_stopTime(const double val) {
  this->stopTime = val;
}

void DefaultExperiment::__set_tolerance(const double val) {
  this->tolerance = val;
}

void DefaultExperiment::__set_stepSize(const double val) {
  this->stepSize = val;
}
std::ostream& operator<<(std::ostream& out, const DefaultExperiment& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t DefaultExperiment::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->startTime);
          this->__isset.startTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->stopTime);
          this->__isset.stopTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->tolerance);
          this->__isset.tolerance = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->stepSize);
          this->__isset.stepSize = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DefaultExperiment::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DefaultExperiment");

  xfer += oprot->writeFieldBegin("startTime", ::apache::thrift::protocol::T_DOUBLE, 1);
  xfer += oprot->writeDouble(this->startTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("stopTime", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->stopTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tolerance", ::apache::thrift::protocol::T_DOUBLE, 3);
  xfer += oprot->writeDouble(this->tolerance);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("stepSize", ::apache::thrift::protocol::T_DOUBLE, 4);
  xfer += oprot->writeDouble(this->stepSize);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DefaultExperiment &a, DefaultExperiment &b) {
  using ::std::swap;
  swap(a.startTime, b.startTime);
  swap(a.stopTime, b.stopTime);
  swap(a.tolerance, b.tolerance);
  swap(a.stepSize, b.stepSize);
  swap(a.__isset, b.__isset);
}

DefaultExperiment::DefaultExperiment(const DefaultExperiment& other48) {
  startTime = other48.startTime;
  stopTime = other48.stopTime;
  tolerance = other48.tolerance;
  stepSize = other48.stepSize;
  __isset = other48.__isset;
}
DefaultExperiment& DefaultExperiment::operator=(const DefaultExperiment& other49) {
  startTime = other49.startTime;
  stopTime = other49.stopTime;
  tolerance = other49.tolerance;
  stepSize = other49.stepSize;
  __isset = other49.__isset;
  return *this;
}
void DefaultExperiment::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DefaultExperiment(";
  out << "startTime=" << to_string(startTime);
  out << ", " << "stopTime=" << to_string(stopTime);
  out << ", " << "tolerance=" << to_string(tolerance);
  out << ", " << "stepSize=" << to_string(stepSize);
  out << ")";
}


StepResult::~StepResult() noexcept {
}


void StepResult::__set_status(const Status::type val) {
  this->status = val;
}

void StepResult::__set_simulationTime(const double val) {
  this->simulationTime = val;
}
std::ostream& operator<<(std::ostream& out, const StepResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t StepResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast50;
          xfer += iprot->readI32(ecast50);
          this->status = (Status::type)ecast50;
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->simulationTime);
          this->__isset.simulationTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t StepResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("StepResult");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("simulationTime", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->simulationTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(StepResult &a, StepResult &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.simulationTime, b.simulationTime);
  swap(a.__isset, b.__isset);
}

StepResult::StepResult(const StepResult& other51) {
  status = other51.status;
  simulationTime = other51.simulationTime;
  __isset = other51.__isset;
}
StepResult& StepResult::operator=(const StepResult& other52) {
  status = other52.status;
  simulationTime = other52.simulationTime;
  __isset = other52.__isset;
  return *this;
}
void StepResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "StepResult(";
  out << "status=" << to_string(status);
  out << ", " << "simulationTime=" << to_string(simulationTime);
  out << ")";
}


IntegerRead::~IntegerRead() noexcept {
}


void IntegerRead::__set_value(const std::vector<int32_t> & val) {
  this->value = val;
}

void IntegerRead::__set_status(const Status::type val) {
  this->status = val;
}
std::ostream& operator<<(std::ostream& out, const IntegerRead& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t IntegerRead::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->value.clear();
            uint32_t _size53;
            ::apache::thrift::protocol::TType _etype56;
            xfer += iprot->readListBegin(_etype56, _size53);
            this->value.resize(_size53);
            uint32_t _i57;
            for (_i57 = 0; _i57 < _size53; ++_i57)
            {
              xfer += iprot->readI32(this->value[_i57]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast58;
          xfer += iprot->readI32(ecast58);
          this->status = (Status::type)ecast58;
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t IntegerRead::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("IntegerRead");

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->value.size()));
    std::vector<int32_t> ::const_iterator _iter59;
    for (_iter59 = this->value.begin(); _iter59 != this->value.end(); ++_iter59)
    {
      xfer += oprot->writeI32((*_iter59));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(IntegerRead &a, IntegerRead &b) {
  using ::std::swap;
  swap(a.value, b.value);
  swap(a.status, b.status);
  swap(a.__isset, b.__isset);
}

IntegerRead::IntegerRead(const IntegerRead& other60) {
  value = other60.value;
  status = other60.status;
  __isset = other60.__isset;
}
IntegerRead& IntegerRead::operator=(const IntegerRead& other61) {
  value = other61.value;
  status = other61.status;
  __isset = other61.__isset;
  return *this;
}
void IntegerRead::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "IntegerRead(";
  out << "value=" << to_string(value);
  out << ", " << "status=" << to_string(status);
  out << ")";
}


RealRead::~RealRead() noexcept {
}


void RealRead::__set_value(const std::vector<double> & val) {
  this->value = val;
}

void RealRead::__set_status(const Status::type val) {
  this->status = val;
}
std::ostream& operator<<(std::ostream& out, const RealRead& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t RealRead::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->value.clear();
            uint32_t _size62;
            ::apache::thrift::protocol::TType _etype65;
            xfer += iprot->readListBegin(_etype65, _size62);
            this->value.resize(_size62);
            uint32_t _i66;
            for (_i66 = 0; _i66 < _size62; ++_i66)
            {
              xfer += iprot->readDouble(this->value[_i66]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast67;
          xfer += iprot->readI32(ecast67);
          this->status = (Status::type)ecast67;
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t RealRead::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("RealRead");

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->value.size()));
    std::vector<double> ::const_iterator _iter68;
    for (_iter68 = this->value.begin(); _iter68 != this->value.end(); ++_iter68)
    {
      xfer += oprot->writeDouble((*_iter68));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RealRead &a, RealRead &b) {
  using ::std::swap;
  swap(a.value, b.value);
  swap(a.status, b.status);
  swap(a.__isset, b.__isset);
}

RealRead::RealRead(const RealRead& other69) {
  value = other69.value;
  status = other69.status;
  __isset = other69.__isset;
}
RealRead& RealRead::operator=(const RealRead& other70) {
  value = other70.value;
  status = other70.status;
  __isset = other70.__isset;
  return *this;
}
void RealRead::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "RealRead(";
  out << "value=" << to_string(value);
  out << ", " << "status=" << to_string(status);
  out << ")";
}


StringRead::~StringRead() noexcept {
}


void StringRead::__set_value(const std::vector<std::string> & val) {
  this->value = val;
}

void StringRead::__set_status(const Status::type val) {
  this->status = val;
}
std::ostream& operator<<(std::ostream& out, const StringRead& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t StringRead::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->value.clear();
            uint32_t _size71;
            ::apache::thrift::protocol::TType _etype74;
            xfer += iprot->readListBegin(_etype74, _size71);
            this->value.resize(_size71);
            uint32_t _i75;
            for (_i75 = 0; _i75 < _size71; ++_i75)
            {
              xfer += iprot->readString(this->value[_i75]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast76;
          xfer += iprot->readI32(ecast76);
          this->status = (Status::type)ecast76;
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t StringRead::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("StringRead");

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->value.size()));
    std::vector<std::string> ::const_iterator _iter77;
    for (_iter77 = this->value.begin(); _iter77 != this->value.end(); ++_iter77)
    {
      xfer += oprot->writeString((*_iter77));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(StringRead &a, StringRead &b) {
  using ::std::swap;
  swap(a.value, b.value);
  swap(a.status, b.status);
  swap(a.__isset, b.__isset);
}

StringRead::StringRead(const StringRead& other78) {
  value = other78.value;
  status = other78.status;
  __isset = other78.__isset;
}
StringRead& StringRead::operator=(const StringRead& other79) {
  value = other79.value;
  status = other79.status;
  __isset = other79.__isset;
  return *this;
}
void StringRead::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "StringRead(";
  out << "value=" << to_string(value);
  out << ", " << "status=" << to_string(status);
  out << ")";
}


BooleanRead::~BooleanRead() noexcept {
}


void BooleanRead::__set_value(const std::vector<bool> & val) {
  this->value = val;
}

void BooleanRead::__set_status(const Status::type val) {
  this->status = val;
}
std::ostream& operator<<(std::ostream& out, const BooleanRead& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t BooleanRead::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->value.clear();
            uint32_t _size80;
            ::apache::thrift::protocol::TType _etype83;
            xfer += iprot->readListBegin(_etype83, _size80);
            this->value.resize(_size80);
            uint32_t _i84;
            for (_i84 = 0; _i84 < _size80; ++_i84)
            {
              xfer += iprot->readBool(this->value[_i84]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast85;
          xfer += iprot->readI32(ecast85);
          this->status = (Status::type)ecast85;
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BooleanRead::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("BooleanRead");

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_BOOL, static_cast<uint32_t>(this->value.size()));
    std::vector<bool> ::const_iterator _iter86;
    for (_iter86 = this->value.begin(); _iter86 != this->value.end(); ++_iter86)
    {
      xfer += oprot->writeBool((*_iter86));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BooleanRead &a, BooleanRead &b) {
  using ::std::swap;
  swap(a.value, b.value);
  swap(a.status, b.status);
  swap(a.__isset, b.__isset);
}

BooleanRead::BooleanRead(const BooleanRead& other87) {
  value = other87.value;
  status = other87.status;
  __isset = other87.__isset;
}
BooleanRead& BooleanRead::operator=(const BooleanRead& other88) {
  value = other88.value;
  status = other88.status;
  __isset = other88.__isset;
  return *this;
}
void BooleanRead::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "BooleanRead(";
  out << "value=" << to_string(value);
  out << ", " << "status=" << to_string(status);
  out << ")";
}


Solver::~Solver() noexcept {
}


void Solver::__set_name(const std::string& val) {
  this->name = val;
}

void Solver::__set_settings(const std::string& val) {
  this->settings = val;
}
std::ostream& operator<<(std::ostream& out, const Solver& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Solver::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->settings);
          this->__isset.settings = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Solver::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Solver");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("settings", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->settings);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Solver &a, Solver &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.settings, b.settings);
  swap(a.__isset, b.__isset);
}

Solver::Solver(const Solver& other89) {
  name = other89.name;
  settings = other89.settings;
  __isset = other89.__isset;
}
Solver& Solver::operator=(const Solver& other90) {
  name = other90.name;
  settings = other90.settings;
  __isset = other90.__isset;
  return *this;
}
void Solver::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Solver(";
  out << "name=" << to_string(name);
  out << ", " << "settings=" << to_string(settings);
  out << ")";
}


ModelDescription::~ModelDescription() noexcept {
}


void ModelDescription::__set_guid(const std::string& val) {
  this->guid = val;
}

void ModelDescription::__set_fmiVersion(const std::string& val) {
  this->fmiVersion = val;
}

void ModelDescription::__set_modelName(const std::string& val) {
  this->modelName = val;
}

void ModelDescription::__set_license(const std::string& val) {
  this->license = val;
__isset.license = true;
}

void ModelDescription::__set_copyright(const std::string& val) {
  this->copyright = val;
__isset.copyright = true;
}

void ModelDescription::__set_author(const std::string& val) {
  this->author = val;
__isset.author = true;
}

void ModelDescription::__set_version(const std::string& val) {
  this->version = val;
__isset.version = true;
}

void ModelDescription::__set_description(const std::string& val) {
  this->description = val;
__isset.description = true;
}

void ModelDescription::__set_generationTool(const std::string& val) {
  this->generationTool = val;
__isset.generationTool = true;
}

void ModelDescription::__set_generationDateAndTime(const std::string& val) {
  this->generationDateAndTime = val;
__isset.generationDateAndTime = true;
}

void ModelDescription::__set_defaultExperiment(const DefaultExperiment& val) {
  this->defaultExperiment = val;
__isset.defaultExperiment = true;
}

void ModelDescription::__set_variableNamingConvention(const std::string& val) {
  this->variableNamingConvention = val;
__isset.variableNamingConvention = true;
}

void ModelDescription::__set_modelVariables(const ModelVariables& val) {
  this->modelVariables = val;
}

void ModelDescription::__set_modelStructure(const ModelStructure& val) {
  this->modelStructure = val;
}
std::ostream& operator<<(std::ostream& out, const ModelDescription& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ModelDescription::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->guid);
          this->__isset.guid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->fmiVersion);
          this->__isset.fmiVersion = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->modelName);
          this->__isset.modelName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->license);
          this->__isset.license = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->copyright);
          this->__isset.copyright = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->author);
          this->__isset.author = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->version);
          this->__isset.version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->description);
          this->__isset.description = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->generationTool);
          this->__isset.generationTool = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->generationDateAndTime);
          this->__isset.generationDateAndTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->defaultExperiment.read(iprot);
          this->__isset.defaultExperiment = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->variableNamingConvention);
          this->__isset.variableNamingConvention = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->modelVariables.clear();
            uint32_t _size91;
            ::apache::thrift::protocol::TType _etype94;
            xfer += iprot->readListBegin(_etype94, _size91);
            this->modelVariables.resize(_size91);
            uint32_t _i95;
            for (_i95 = 0; _i95 < _size91; ++_i95)
            {
              xfer += this->modelVariables[_i95].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.modelVariables = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->modelStructure.read(iprot);
          this->__isset.modelStructure = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ModelDescription::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ModelDescription");

  xfer += oprot->writeFieldBegin("guid", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->guid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fmiVersion", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->fmiVersion);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("modelName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->modelName);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.license) {
    xfer += oprot->writeFieldBegin("license", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->license);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.copyright) {
    xfer += oprot->writeFieldBegin("copyright", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->copyright);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.author) {
    xfer += oprot->writeFieldBegin("author", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->author);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.version) {
    xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->version);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.description) {
    xfer += oprot->writeFieldBegin("description", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->description);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.generationTool) {
    xfer += oprot->writeFieldBegin("generationTool", ::apache::thrift::protocol::T_STRING, 9);
    xfer += oprot->writeString(this->generationTool);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.generationDateAndTime) {
    xfer += oprot->writeFieldBegin("generationDateAndTime", ::apache::thrift::protocol::T_STRING, 10);
    xfer += oprot->writeString(this->generationDateAndTime);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.defaultExperiment) {
    xfer += oprot->writeFieldBegin("defaultExperiment", ::apache::thrift::protocol::T_STRUCT, 11);
    xfer += this->defaultExperiment.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.variableNamingConvention) {
    xfer += oprot->writeFieldBegin("variableNamingConvention", ::apache::thrift::protocol::T_STRING, 12);
    xfer += oprot->writeString(this->variableNamingConvention);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("modelVariables", ::apache::thrift::protocol::T_LIST, 13);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->modelVariables.size()));
    std::vector<ScalarVariable> ::const_iterator _iter96;
    for (_iter96 = this->modelVariables.begin(); _iter96 != this->modelVariables.end(); ++_iter96)
    {
      xfer += (*_iter96).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("modelStructure", ::apache::thrift::protocol::T_STRUCT, 14);
  xfer += this->modelStructure.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ModelDescription &a, ModelDescription &b) {
  using ::std::swap;
  swap(a.guid, b.guid);
  swap(a.fmiVersion, b.fmiVersion);
  swap(a.modelName, b.modelName);
  swap(a.license, b.license);
  swap(a.copyright, b.copyright);
  swap(a.author, b.author);
  swap(a.version, b.version);
  swap(a.description, b.description);
  swap(a.generationTool, b.generationTool);
  swap(a.generationDateAndTime, b.generationDateAndTime);
  swap(a.defaultExperiment, b.defaultExperiment);
  swap(a.variableNamingConvention, b.variableNamingConvention);
  swap(a.modelVariables, b.modelVariables);
  swap(a.modelStructure, b.modelStructure);
  swap(a.__isset, b.__isset);
}

ModelDescription::ModelDescription(const ModelDescription& other97) {
  guid = other97.guid;
  fmiVersion = other97.fmiVersion;
  modelName = other97.modelName;
  license = other97.license;
  copyright = other97.copyright;
  author = other97.author;
  version = other97.version;
  description = other97.description;
  generationTool = other97.generationTool;
  generationDateAndTime = other97.generationDateAndTime;
  defaultExperiment = other97.defaultExperiment;
  variableNamingConvention = other97.variableNamingConvention;
  modelVariables = other97.modelVariables;
  modelStructure = other97.modelStructure;
  __isset = other97.__isset;
}
ModelDescription& ModelDescription::operator=(const ModelDescription& other98) {
  guid = other98.guid;
  fmiVersion = other98.fmiVersion;
  modelName = other98.modelName;
  license = other98.license;
  copyright = other98.copyright;
  author = other98.author;
  version = other98.version;
  description = other98.description;
  generationTool = other98.generationTool;
  generationDateAndTime = other98.generationDateAndTime;
  defaultExperiment = other98.defaultExperiment;
  variableNamingConvention = other98.variableNamingConvention;
  modelVariables = other98.modelVariables;
  modelStructure = other98.modelStructure;
  __isset = other98.__isset;
  return *this;
}
void ModelDescription::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ModelDescription(";
  out << "guid=" << to_string(guid);
  out << ", " << "fmiVersion=" << to_string(fmiVersion);
  out << ", " << "modelName=" << to_string(modelName);
  out << ", " << "license="; (__isset.license ? (out << to_string(license)) : (out << "<null>"));
  out << ", " << "copyright="; (__isset.copyright ? (out << to_string(copyright)) : (out << "<null>"));
  out << ", " << "author="; (__isset.author ? (out << to_string(author)) : (out << "<null>"));
  out << ", " << "version="; (__isset.version ? (out << to_string(version)) : (out << "<null>"));
  out << ", " << "description="; (__isset.description ? (out << to_string(description)) : (out << "<null>"));
  out << ", " << "generationTool="; (__isset.generationTool ? (out << to_string(generationTool)) : (out << "<null>"));
  out << ", " << "generationDateAndTime="; (__isset.generationDateAndTime ? (out << to_string(generationDateAndTime)) : (out << "<null>"));
  out << ", " << "defaultExperiment="; (__isset.defaultExperiment ? (out << to_string(defaultExperiment)) : (out << "<null>"));
  out << ", " << "variableNamingConvention="; (__isset.variableNamingConvention ? (out << to_string(variableNamingConvention)) : (out << "<null>"));
  out << ", " << "modelVariables=" << to_string(modelVariables);
  out << ", " << "modelStructure=" << to_string(modelStructure);
  out << ")";
}


CoSimulationAttributes::~CoSimulationAttributes() noexcept {
}


void CoSimulationAttributes::__set_modelIdentifier(const std::string& val) {
  this->modelIdentifier = val;
}

void CoSimulationAttributes::__set_canGetAndSetFMUstate(const bool val) {
  this->canGetAndSetFMUstate = val;
}

void CoSimulationAttributes::__set_canSerializeFMUstate(const bool val) {
  this->canSerializeFMUstate = val;
}

void CoSimulationAttributes::__set_providesDirectionalDerivative(const bool val) {
  this->providesDirectionalDerivative = val;
}

void CoSimulationAttributes::__set_canHandleVariableCommunicationStepSize(const bool val) {
  this->canHandleVariableCommunicationStepSize = val;
}

void CoSimulationAttributes::__set_canInterpolateInputs(const bool val) {
  this->canInterpolateInputs = val;
}

void CoSimulationAttributes::__set_maxOutputDerivativeOrder(const int32_t val) {
  this->maxOutputDerivativeOrder = val;
}
std::ostream& operator<<(std::ostream& out, const CoSimulationAttributes& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CoSimulationAttributes::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->modelIdentifier);
          this->__isset.modelIdentifier = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->canGetAndSetFMUstate);
          this->__isset.canGetAndSetFMUstate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->canSerializeFMUstate);
          this->__isset.canSerializeFMUstate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->providesDirectionalDerivative);
          this->__isset.providesDirectionalDerivative = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->canHandleVariableCommunicationStepSize);
          this->__isset.canHandleVariableCommunicationStepSize = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->canInterpolateInputs);
          this->__isset.canInterpolateInputs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxOutputDerivativeOrder);
          this->__isset.maxOutputDerivativeOrder = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CoSimulationAttributes::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CoSimulationAttributes");

  xfer += oprot->writeFieldBegin("modelIdentifier", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->modelIdentifier);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("canGetAndSetFMUstate", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->canGetAndSetFMUstate);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("canSerializeFMUstate", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->canSerializeFMUstate);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("providesDirectionalDerivative", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->providesDirectionalDerivative);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("canHandleVariableCommunicationStepSize", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->canHandleVariableCommunicationStepSize);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("canInterpolateInputs", ::apache::thrift::protocol::T_BOOL, 6);
  xfer += oprot->writeBool(this->canInterpolateInputs);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxOutputDerivativeOrder", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->maxOutputDerivativeOrder);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CoSimulationAttributes &a, CoSimulationAttributes &b) {
  using ::std::swap;
  swap(a.modelIdentifier, b.modelIdentifier);
  swap(a.canGetAndSetFMUstate, b.canGetAndSetFMUstate);
  swap(a.canSerializeFMUstate, b.canSerializeFMUstate);
  swap(a.providesDirectionalDerivative, b.providesDirectionalDerivative);
  swap(a.canHandleVariableCommunicationStepSize, b.canHandleVariableCommunicationStepSize);
  swap(a.canInterpolateInputs, b.canInterpolateInputs);
  swap(a.maxOutputDerivativeOrder, b.maxOutputDerivativeOrder);
  swap(a.__isset, b.__isset);
}

CoSimulationAttributes::CoSimulationAttributes(const CoSimulationAttributes& other99) {
  modelIdentifier = other99.modelIdentifier;
  canGetAndSetFMUstate = other99.canGetAndSetFMUstate;
  canSerializeFMUstate = other99.canSerializeFMUstate;
  providesDirectionalDerivative = other99.providesDirectionalDerivative;
  canHandleVariableCommunicationStepSize = other99.canHandleVariableCommunicationStepSize;
  canInterpolateInputs = other99.canInterpolateInputs;
  maxOutputDerivativeOrder = other99.maxOutputDerivativeOrder;
  __isset = other99.__isset;
}
CoSimulationAttributes& CoSimulationAttributes::operator=(const CoSimulationAttributes& other100) {
  modelIdentifier = other100.modelIdentifier;
  canGetAndSetFMUstate = other100.canGetAndSetFMUstate;
  canSerializeFMUstate = other100.canSerializeFMUstate;
  providesDirectionalDerivative = other100.providesDirectionalDerivative;
  canHandleVariableCommunicationStepSize = other100.canHandleVariableCommunicationStepSize;
  canInterpolateInputs = other100.canInterpolateInputs;
  maxOutputDerivativeOrder = other100.maxOutputDerivativeOrder;
  __isset = other100.__isset;
  return *this;
}
void CoSimulationAttributes::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CoSimulationAttributes(";
  out << "modelIdentifier=" << to_string(modelIdentifier);
  out << ", " << "canGetAndSetFMUstate=" << to_string(canGetAndSetFMUstate);
  out << ", " << "canSerializeFMUstate=" << to_string(canSerializeFMUstate);
  out << ", " << "providesDirectionalDerivative=" << to_string(providesDirectionalDerivative);
  out << ", " << "canHandleVariableCommunicationStepSize=" << to_string(canHandleVariableCommunicationStepSize);
  out << ", " << "canInterpolateInputs=" << to_string(canInterpolateInputs);
  out << ", " << "maxOutputDerivativeOrder=" << to_string(maxOutputDerivativeOrder);
  out << ")";
}


NoSuchFmuException::~NoSuchFmuException() noexcept {
}


void NoSuchFmuException::__set_message(const std::string& val) {
  this->message = val;
}
std::ostream& operator<<(std::ostream& out, const NoSuchFmuException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t NoSuchFmuException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoSuchFmuException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoSuchFmuException");

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NoSuchFmuException &a, NoSuchFmuException &b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

NoSuchFmuException::NoSuchFmuException(const NoSuchFmuException& other101) : TException() {
  message = other101.message;
  __isset = other101.__isset;
}
NoSuchFmuException& NoSuchFmuException::operator=(const NoSuchFmuException& other102) {
  message = other102.message;
  __isset = other102.__isset;
  return *this;
}
void NoSuchFmuException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "NoSuchFmuException(";
  out << "message=" << to_string(message);
  out << ")";
}

const char* NoSuchFmuException::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: NoSuchFmuException";
  }
}


NoSuchInstanceException::~NoSuchInstanceException() noexcept {
}


void NoSuchInstanceException::__set_message(const std::string& val) {
  this->message = val;
}
std::ostream& operator<<(std::ostream& out, const NoSuchInstanceException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t NoSuchInstanceException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoSuchInstanceException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoSuchInstanceException");

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NoSuchInstanceException &a, NoSuchInstanceException &b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

NoSuchInstanceException::NoSuchInstanceException(const NoSuchInstanceException& other103) : TException() {
  message = other103.message;
  __isset = other103.__isset;
}
NoSuchInstanceException& NoSuchInstanceException::operator=(const NoSuchInstanceException& other104) {
  message = other104.message;
  __isset = other104.__isset;
  return *this;
}
void NoSuchInstanceException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "NoSuchInstanceException(";
  out << "message=" << to_string(message);
  out << ")";
}

const char* NoSuchInstanceException::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: NoSuchInstanceException";
  }
}


NoSuchVariableException::~NoSuchVariableException() noexcept {
}


void NoSuchVariableException::__set_message(const std::string& val) {
  this->message = val;
}
std::ostream& operator<<(std::ostream& out, const NoSuchVariableException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t NoSuchVariableException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoSuchVariableException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoSuchVariableException");

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NoSuchVariableException &a, NoSuchVariableException &b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

NoSuchVariableException::NoSuchVariableException(const NoSuchVariableException& other105) : TException() {
  message = other105.message;
  __isset = other105.__isset;
}
NoSuchVariableException& NoSuchVariableException::operator=(const NoSuchVariableException& other106) {
  message = other106.message;
  __isset = other106.__isset;
  return *this;
}
void NoSuchVariableException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "NoSuchVariableException(";
  out << "message=" << to_string(message);
  out << ")";
}

const char* NoSuchVariableException::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: NoSuchVariableException";
  }
}


UnsupportedOperationException::~UnsupportedOperationException() noexcept {
}


void UnsupportedOperationException::__set_message(const std::string& val) {
  this->message = val;
}
std::ostream& operator<<(std::ostream& out, const UnsupportedOperationException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t UnsupportedOperationException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t UnsupportedOperationException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("UnsupportedOperationException");

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UnsupportedOperationException &a, UnsupportedOperationException &b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

UnsupportedOperationException::UnsupportedOperationException(const UnsupportedOperationException& other107) : TException() {
  message = other107.message;
  __isset = other107.__isset;
}
UnsupportedOperationException& UnsupportedOperationException::operator=(const UnsupportedOperationException& other108) {
  message = other108.message;
  __isset = other108.__isset;
  return *this;
}
void UnsupportedOperationException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "UnsupportedOperationException(";
  out << "message=" << to_string(message);
  out << ")";
}

const char* UnsupportedOperationException::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: UnsupportedOperationException";
  }
}


GetFmuStateResult::~GetFmuStateResult() noexcept {
}


void GetFmuStateResult::__set_state(const FmuState val) {
  this->state = val;
}

void GetFmuStateResult::__set_status(const Status::type val) {
  this->status = val;
}
std::ostream& operator<<(std::ostream& out, const GetFmuStateResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetFmuStateResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->state);
          this->__isset.state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast109;
          xfer += iprot->readI32(ecast109);
          this->status = (Status::type)ecast109;
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GetFmuStateResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetFmuStateResult");

  xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->state);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetFmuStateResult &a, GetFmuStateResult &b) {
  using ::std::swap;
  swap(a.state, b.state);
  swap(a.status, b.status);
  swap(a.__isset, b.__isset);
}

GetFmuStateResult::GetFmuStateResult(const GetFmuStateResult& other110) {
  state = other110.state;
  status = other110.status;
  __isset = other110.__isset;
}
GetFmuStateResult& GetFmuStateResult::operator=(const GetFmuStateResult& other111) {
  state = other111.state;
  status = other111.status;
  __isset = other111.__isset;
  return *this;
}
void GetFmuStateResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetFmuStateResult(";
  out << "state=" << to_string(state);
  out << ", " << "status=" << to_string(status);
  out << ")";
}


SerializeFmuStateResult::~SerializeFmuStateResult() noexcept {
}


void SerializeFmuStateResult::__set_state(const std::string& val) {
  this->state = val;
}

void SerializeFmuStateResult::__set_status(const Status::type val) {
  this->status = val;
}
std::ostream& operator<<(std::ostream& out, const SerializeFmuStateResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SerializeFmuStateResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->state);
          this->__isset.state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast112;
          xfer += iprot->readI32(ecast112);
          this->status = (Status::type)ecast112;
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SerializeFmuStateResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SerializeFmuStateResult");

  xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->state);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SerializeFmuStateResult &a, SerializeFmuStateResult &b) {
  using ::std::swap;
  swap(a.state, b.state);
  swap(a.status, b.status);
  swap(a.__isset, b.__isset);
}

SerializeFmuStateResult::SerializeFmuStateResult(const SerializeFmuStateResult& other113) {
  state = other113.state;
  status = other113.status;
  __isset = other113.__isset;
}
SerializeFmuStateResult& SerializeFmuStateResult::operator=(const SerializeFmuStateResult& other114) {
  state = other114.state;
  status = other114.status;
  __isset = other114.__isset;
  return *this;
}
void SerializeFmuStateResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SerializeFmuStateResult(";
  out << "state=" << to_string(state);
  out << ", " << "status=" << to_string(status);
  out << ")";
}


DeSerializeFmuStateResult::~DeSerializeFmuStateResult() noexcept {
}


void DeSerializeFmuStateResult::__set_state(const FmuState val) {
  this->state = val;
}

void DeSerializeFmuStateResult::__set_status(const Status::type val) {
  this->status = val;
}
std::ostream& operator<<(std::ostream& out, const DeSerializeFmuStateResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t DeSerializeFmuStateResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->state);
          this->__isset.state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast115;
          xfer += iprot->readI32(ecast115);
          this->status = (Status::type)ecast115;
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DeSerializeFmuStateResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DeSerializeFmuStateResult");

  xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->state);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DeSerializeFmuStateResult &a, DeSerializeFmuStateResult &b) {
  using ::std::swap;
  swap(a.state, b.state);
  swap(a.status, b.status);
  swap(a.__isset, b.__isset);
}

DeSerializeFmuStateResult::DeSerializeFmuStateResult(const DeSerializeFmuStateResult& other116) {
  state = other116.state;
  status = other116.status;
  __isset = other116.__isset;
}
DeSerializeFmuStateResult& DeSerializeFmuStateResult::operator=(const DeSerializeFmuStateResult& other117) {
  state = other117.state;
  status = other117.status;
  __isset = other117.__isset;
  return *this;
}
void DeSerializeFmuStateResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DeSerializeFmuStateResult(";
  out << "state=" << to_string(state);
  out << ", " << "status=" << to_string(status);
  out << ")";
}


DirectionalDerivativeResult::~DirectionalDerivativeResult() noexcept {
}


void DirectionalDerivativeResult::__set_dvUnknownRef(const DirectionalDerivative& val) {
  this->dvUnknownRef = val;
}

void DirectionalDerivativeResult::__set_status(const Status::type val) {
  this->status = val;
}
std::ostream& operator<<(std::ostream& out, const DirectionalDerivativeResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t DirectionalDerivativeResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->dvUnknownRef.clear();
            uint32_t _size118;
            ::apache::thrift::protocol::TType _etype121;
            xfer += iprot->readListBegin(_etype121, _size118);
            this->dvUnknownRef.resize(_size118);
            uint32_t _i122;
            for (_i122 = 0; _i122 < _size118; ++_i122)
            {
              xfer += iprot->readDouble(this->dvUnknownRef[_i122]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.dvUnknownRef = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast123;
          xfer += iprot->readI32(ecast123);
          this->status = (Status::type)ecast123;
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DirectionalDerivativeResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DirectionalDerivativeResult");

  xfer += oprot->writeFieldBegin("dvUnknownRef", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->dvUnknownRef.size()));
    std::vector<double> ::const_iterator _iter124;
    for (_iter124 = this->dvUnknownRef.begin(); _iter124 != this->dvUnknownRef.end(); ++_iter124)
    {
      xfer += oprot->writeDouble((*_iter124));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DirectionalDerivativeResult &a, DirectionalDerivativeResult &b) {
  using ::std::swap;
  swap(a.dvUnknownRef, b.dvUnknownRef);
  swap(a.status, b.status);
  swap(a.__isset, b.__isset);
}

DirectionalDerivativeResult::DirectionalDerivativeResult(const DirectionalDerivativeResult& other125) {
  dvUnknownRef = other125.dvUnknownRef;
  status = other125.status;
  __isset = other125.__isset;
}
DirectionalDerivativeResult& DirectionalDerivativeResult::operator=(const DirectionalDerivativeResult& other126) {
  dvUnknownRef = other126.dvUnknownRef;
  status = other126.status;
  __isset = other126.__isset;
  return *this;
}
void DirectionalDerivativeResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DirectionalDerivativeResult(";
  out << "dvUnknownRef=" << to_string(dvUnknownRef);
  out << ", " << "status=" << to_string(status);
  out << ")";
}

}} // namespace
