/**
 * Autogenerated by Thrift Compiler (1.0.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

//#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

#include "cse/fmuproxy/service_types.hpp"

namespace fmuproxy {
    namespace thrift {

        int _kStatusValues[] = {
                Status::OK_STATUS,
                Status::WARNING_STATUS,
                Status::DISCARD_STATUS,
                Status::ERROR_STATUS,
                Status::FATAL_STATUS,
                Status::PENDING_STATUS
        };
        const char *_kStatusNames[] = {
                "OK_STATUS",
                "WARNING_STATUS",
                "DISCARD_STATUS",
                "ERROR_STATUS",
                "FATAL_STATUS",
                "PENDING_STATUS"
        };
        const std::map<int, const char *> _Status_VALUES_TO_NAMES(
                ::apache::thrift::TEnumIterator(6, _kStatusValues, _kStatusNames),
                ::apache::thrift::TEnumIterator(-1, NULL, NULL));

        std::ostream &operator<<(std::ostream &out, const Status::type &val) {
            std::map<int, const char *>::const_iterator it = _Status_VALUES_TO_NAMES.find(val);
            if (it != _Status_VALUES_TO_NAMES.end()) {
                out << it->second;
            } else {
                out << static_cast<int>(val);
            }
            return out;
        }

        int _kCausalityValues[] = {
                Causality::INPUT_CAUSALITY,
                Causality::OUTPUT_CAUSALITY,
                Causality::PARAMETER_CAUSALITY,
                Causality::CALCULATED_PARAMETER_CAUSALITY,
                Causality::LOCAL_CAUSALITY,
                Causality::INDEPENDENT_CAUSALITY,
                Causality::UNKNOWN_CAUSALITY
        };
        const char *_kCausalityNames[] = {
                "INPUT_CAUSALITY",
                "OUTPUT_CAUSALITY",
                "PARAMETER_CAUSALITY",
                "CALCULATED_PARAMETER_CAUSALITY",
                "LOCAL_CAUSALITY",
                "INDEPENDENT_CAUSALITY",
                "UNKNOWN_CAUSALITY"
        };
        const std::map<int, const char *> _Causality_VALUES_TO_NAMES(
                ::apache::thrift::TEnumIterator(7, _kCausalityValues, _kCausalityNames),
                ::apache::thrift::TEnumIterator(-1, NULL, NULL));

        std::ostream &operator<<(std::ostream &out, const Causality::type &val) {
            std::map<int, const char *>::const_iterator it = _Causality_VALUES_TO_NAMES.find(val);
            if (it != _Causality_VALUES_TO_NAMES.end()) {
                out << it->second;
            } else {
                out << static_cast<int>(val);
            }
            return out;
        }

        int _kVariabilityValues[] = {
                Variability::CONSTANT_VARIABILITY,
                Variability::FIXED_VARIABILITY,
                Variability::CONTINUOUS_VARIABILITY,
                Variability::DISCRETE_VARIABILITY,
                Variability::TUNABLE_VARIABILITY,
                Variability::UNKNOWN_VARIABILITY
        };
        const char *_kVariabilityNames[] = {
                "CONSTANT_VARIABILITY",
                "FIXED_VARIABILITY",
                "CONTINUOUS_VARIABILITY",
                "DISCRETE_VARIABILITY",
                "TUNABLE_VARIABILITY",
                "UNKNOWN_VARIABILITY"
        };
        const std::map<int, const char *> _Variability_VALUES_TO_NAMES(
                ::apache::thrift::TEnumIterator(6, _kVariabilityValues, _kVariabilityNames),
                ::apache::thrift::TEnumIterator(-1, NULL, NULL));

        std::ostream &operator<<(std::ostream &out, const Variability::type &val) {
            std::map<int, const char *>::const_iterator it = _Variability_VALUES_TO_NAMES.find(val);
            if (it != _Variability_VALUES_TO_NAMES.end()) {
                out << it->second;
            } else {
                out << static_cast<int>(val);
            }
            return out;
        }

        int _kInitialValues[] = {
                Initial::EXACT_INITIAL,
                Initial::APPROX_INITIAL,
                Initial::CALCULATED_INITIAL,
                Initial::UNKNOWN_INITIAL
        };
        const char *_kInitialNames[] = {
                "EXACT_INITIAL",
                "APPROX_INITIAL",
                "CALCULATED_INITIAL",
                "UNKNOWN_INITIAL"
        };
        const std::map<int, const char *> _Initial_VALUES_TO_NAMES(
                ::apache::thrift::TEnumIterator(4, _kInitialValues, _kInitialNames),
                ::apache::thrift::TEnumIterator(-1, NULL, NULL));

        std::ostream &operator<<(std::ostream &out, const Initial::type &val) {
            std::map<int, const char *>::const_iterator it = _Initial_VALUES_TO_NAMES.find(val);
            if (it != _Initial_VALUES_TO_NAMES.end()) {
                out << it->second;
            } else {
                out << static_cast<int>(val);
            }
            return out;
        }


        IntegerAttribute::~IntegerAttribute() noexcept {
        }


        void IntegerAttribute::__set_min(const int32_t val) {
            this->min = val;
        }

        void IntegerAttribute::__set_max(const int32_t val) {
            this->max = val;
        }

        void IntegerAttribute::__set_start(const int32_t val) {
            this->start = val;
        }

        void IntegerAttribute::__set_quantity(const std::string &val) {
            this->quantity = val;
        }

        std::ostream &operator<<(std::ostream &out, const IntegerAttribute &obj) {
            obj.printTo(out);
            return out;
        }


        uint32_t IntegerAttribute::read(::apache::thrift::protocol::TProtocol *iprot) {

            ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
            uint32_t xfer = 0;
            std::string fname;
            ::apache::thrift::protocol::TType ftype;
            int16_t fid;

            xfer += iprot->readStructBegin(fname);

            using ::apache::thrift::protocol::TProtocolException;


            while (true) {
                xfer += iprot->readFieldBegin(fname, ftype, fid);
                if (ftype == ::apache::thrift::protocol::T_STOP) {
                    break;
                }
                switch (fid) {
                    case 1:
                        if (ftype == ::apache::thrift::protocol::T_I32) {
                            xfer += iprot->readI32(this->min);
                            this->__isset.min = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    case 2:
                        if (ftype == ::apache::thrift::protocol::T_I32) {
                            xfer += iprot->readI32(this->max);
                            this->__isset.max = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    case 3:
                        if (ftype == ::apache::thrift::protocol::T_I32) {
                            xfer += iprot->readI32(this->start);
                            this->__isset.start = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    case 4:
                        if (ftype == ::apache::thrift::protocol::T_STRING) {
                            xfer += iprot->readString(this->quantity);
                            this->__isset.quantity = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
                }
                xfer += iprot->readFieldEnd();
            }

            xfer += iprot->readStructEnd();

            return xfer;
        }

        uint32_t IntegerAttribute::write(::apache::thrift::protocol::TProtocol *oprot) const {
            uint32_t xfer = 0;
            ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
            xfer += oprot->writeStructBegin("IntegerAttribute");

            xfer += oprot->writeFieldBegin("min", ::apache::thrift::protocol::T_I32, 1);
            xfer += oprot->writeI32(this->min);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldBegin("max", ::apache::thrift::protocol::T_I32, 2);
            xfer += oprot->writeI32(this->max);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldBegin("start", ::apache::thrift::protocol::T_I32, 3);
            xfer += oprot->writeI32(this->start);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldBegin("quantity", ::apache::thrift::protocol::T_STRING, 4);
            xfer += oprot->writeString(this->quantity);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldStop();
            xfer += oprot->writeStructEnd();
            return xfer;
        }

        void swap(IntegerAttribute &a, IntegerAttribute &b) {
            using ::std::swap;
            swap(a.min, b.min);
            swap(a.max, b.max);
            swap(a.start, b.start);
            swap(a.quantity, b.quantity);
            swap(a.__isset, b.__isset);
        }

        IntegerAttribute::IntegerAttribute(const IntegerAttribute &other0) {
            min = other0.min;
            max = other0.max;
            start = other0.start;
            quantity = other0.quantity;
            __isset = other0.__isset;
        }

        IntegerAttribute &IntegerAttribute::operator=(const IntegerAttribute &other1) {
            min = other1.min;
            max = other1.max;
            start = other1.start;
            quantity = other1.quantity;
            __isset = other1.__isset;
            return *this;
        }

        void IntegerAttribute::printTo(std::ostream &out) const {
            using ::apache::thrift::to_string;
            out << "IntegerAttribute(";
            out << "min=" << to_string(min);
            out << ", " << "max=" << to_string(max);
            out << ", " << "start=" << to_string(start);
            out << ", " << "quantity=" << to_string(quantity);
            out << ")";
        }


        RealAttribute::~RealAttribute() noexcept {
        }


        void RealAttribute::__set_min(const double val) {
            this->min = val;
        }

        void RealAttribute::__set_max(const double val) {
            this->max = val;
        }

        void RealAttribute::__set_start(const double val) {
            this->start = val;
        }

        void RealAttribute::__set_quantity(const std::string &val) {
            this->quantity = val;
        }

        std::ostream &operator<<(std::ostream &out, const RealAttribute &obj) {
            obj.printTo(out);
            return out;
        }


        uint32_t RealAttribute::read(::apache::thrift::protocol::TProtocol *iprot) {

            ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
            uint32_t xfer = 0;
            std::string fname;
            ::apache::thrift::protocol::TType ftype;
            int16_t fid;

            xfer += iprot->readStructBegin(fname);

            using ::apache::thrift::protocol::TProtocolException;


            while (true) {
                xfer += iprot->readFieldBegin(fname, ftype, fid);
                if (ftype == ::apache::thrift::protocol::T_STOP) {
                    break;
                }
                switch (fid) {
                    case 1:
                        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
                            xfer += iprot->readDouble(this->min);
                            this->__isset.min = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    case 2:
                        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
                            xfer += iprot->readDouble(this->max);
                            this->__isset.max = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    case 3:
                        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
                            xfer += iprot->readDouble(this->start);
                            this->__isset.start = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    case 4:
                        if (ftype == ::apache::thrift::protocol::T_STRING) {
                            xfer += iprot->readString(this->quantity);
                            this->__isset.quantity = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
                }
                xfer += iprot->readFieldEnd();
            }

            xfer += iprot->readStructEnd();

            return xfer;
        }

        uint32_t RealAttribute::write(::apache::thrift::protocol::TProtocol *oprot) const {
            uint32_t xfer = 0;
            ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
            xfer += oprot->writeStructBegin("RealAttribute");

            xfer += oprot->writeFieldBegin("min", ::apache::thrift::protocol::T_DOUBLE, 1);
            xfer += oprot->writeDouble(this->min);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldBegin("max", ::apache::thrift::protocol::T_DOUBLE, 2);
            xfer += oprot->writeDouble(this->max);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldBegin("start", ::apache::thrift::protocol::T_DOUBLE, 3);
            xfer += oprot->writeDouble(this->start);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldBegin("quantity", ::apache::thrift::protocol::T_STRING, 4);
            xfer += oprot->writeString(this->quantity);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldStop();
            xfer += oprot->writeStructEnd();
            return xfer;
        }

        void swap(RealAttribute &a, RealAttribute &b) {
            using ::std::swap;
            swap(a.min, b.min);
            swap(a.max, b.max);
            swap(a.start, b.start);
            swap(a.quantity, b.quantity);
            swap(a.__isset, b.__isset);
        }

        RealAttribute::RealAttribute(const RealAttribute &other2) {
            min = other2.min;
            max = other2.max;
            start = other2.start;
            quantity = other2.quantity;
            __isset = other2.__isset;
        }

        RealAttribute &RealAttribute::operator=(const RealAttribute &other3) {
            min = other3.min;
            max = other3.max;
            start = other3.start;
            quantity = other3.quantity;
            __isset = other3.__isset;
            return *this;
        }

        void RealAttribute::printTo(std::ostream &out) const {
            using ::apache::thrift::to_string;
            out << "RealAttribute(";
            out << "min=" << to_string(min);
            out << ", " << "max=" << to_string(max);
            out << ", " << "start=" << to_string(start);
            out << ", " << "quantity=" << to_string(quantity);
            out << ")";
        }


        StringAttribute::~StringAttribute() noexcept {
        }


        void StringAttribute::__set_start(const std::string &val) {
            this->start = val;
        }

        std::ostream &operator<<(std::ostream &out, const StringAttribute &obj) {
            obj.printTo(out);
            return out;
        }


        uint32_t StringAttribute::read(::apache::thrift::protocol::TProtocol *iprot) {

            ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
            uint32_t xfer = 0;
            std::string fname;
            ::apache::thrift::protocol::TType ftype;
            int16_t fid;

            xfer += iprot->readStructBegin(fname);

            using ::apache::thrift::protocol::TProtocolException;


            while (true) {
                xfer += iprot->readFieldBegin(fname, ftype, fid);
                if (ftype == ::apache::thrift::protocol::T_STOP) {
                    break;
                }
                switch (fid) {
                    case 1:
                        if (ftype == ::apache::thrift::protocol::T_STRING) {
                            xfer += iprot->readString(this->start);
                            this->__isset.start = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
                }
                xfer += iprot->readFieldEnd();
            }

            xfer += iprot->readStructEnd();

            return xfer;
        }

        uint32_t StringAttribute::write(::apache::thrift::protocol::TProtocol *oprot) const {
            uint32_t xfer = 0;
            ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
            xfer += oprot->writeStructBegin("StringAttribute");

            xfer += oprot->writeFieldBegin("start", ::apache::thrift::protocol::T_STRING, 1);
            xfer += oprot->writeString(this->start);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldStop();
            xfer += oprot->writeStructEnd();
            return xfer;
        }

        void swap(StringAttribute &a, StringAttribute &b) {
            using ::std::swap;
            swap(a.start, b.start);
            swap(a.__isset, b.__isset);
        }

        StringAttribute::StringAttribute(const StringAttribute &other4) {
            start = other4.start;
            __isset = other4.__isset;
        }

        StringAttribute &StringAttribute::operator=(const StringAttribute &other5) {
            start = other5.start;
            __isset = other5.__isset;
            return *this;
        }

        void StringAttribute::printTo(std::ostream &out) const {
            using ::apache::thrift::to_string;
            out << "StringAttribute(";
            out << "start=" << to_string(start);
            out << ")";
        }


        BooleanAttribute::~BooleanAttribute() noexcept {
        }


        void BooleanAttribute::__set_start(const bool val) {
            this->start = val;
        }

        std::ostream &operator<<(std::ostream &out, const BooleanAttribute &obj) {
            obj.printTo(out);
            return out;
        }


        uint32_t BooleanAttribute::read(::apache::thrift::protocol::TProtocol *iprot) {

            ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
            uint32_t xfer = 0;
            std::string fname;
            ::apache::thrift::protocol::TType ftype;
            int16_t fid;

            xfer += iprot->readStructBegin(fname);

            using ::apache::thrift::protocol::TProtocolException;


            while (true) {
                xfer += iprot->readFieldBegin(fname, ftype, fid);
                if (ftype == ::apache::thrift::protocol::T_STOP) {
                    break;
                }
                switch (fid) {
                    case 1:
                        if (ftype == ::apache::thrift::protocol::T_BOOL) {
                            xfer += iprot->readBool(this->start);
                            this->__isset.start = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
                }
                xfer += iprot->readFieldEnd();
            }

            xfer += iprot->readStructEnd();

            return xfer;
        }

        uint32_t BooleanAttribute::write(::apache::thrift::protocol::TProtocol *oprot) const {
            uint32_t xfer = 0;
            ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
            xfer += oprot->writeStructBegin("BooleanAttribute");

            xfer += oprot->writeFieldBegin("start", ::apache::thrift::protocol::T_BOOL, 1);
            xfer += oprot->writeBool(this->start);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldStop();
            xfer += oprot->writeStructEnd();
            return xfer;
        }

        void swap(BooleanAttribute &a, BooleanAttribute &b) {
            using ::std::swap;
            swap(a.start, b.start);
            swap(a.__isset, b.__isset);
        }

        BooleanAttribute::BooleanAttribute(const BooleanAttribute &other6) {
            start = other6.start;
            __isset = other6.__isset;
        }

        BooleanAttribute &BooleanAttribute::operator=(const BooleanAttribute &other7) {
            start = other7.start;
            __isset = other7.__isset;
            return *this;
        }

        void BooleanAttribute::printTo(std::ostream &out) const {
            using ::apache::thrift::to_string;
            out << "BooleanAttribute(";
            out << "start=" << to_string(start);
            out << ")";
        }


        EnumerationAttribute::~EnumerationAttribute() noexcept {
        }


        void EnumerationAttribute::__set_min(const int32_t val) {
            this->min = val;
        }

        void EnumerationAttribute::__set_max(const int32_t val) {
            this->max = val;
        }

        void EnumerationAttribute::__set_start(const int32_t val) {
            this->start = val;
        }

        void EnumerationAttribute::__set_quantity(const std::string &val) {
            this->quantity = val;
        }

        std::ostream &operator<<(std::ostream &out, const EnumerationAttribute &obj) {
            obj.printTo(out);
            return out;
        }


        uint32_t EnumerationAttribute::read(::apache::thrift::protocol::TProtocol *iprot) {

            ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
            uint32_t xfer = 0;
            std::string fname;
            ::apache::thrift::protocol::TType ftype;
            int16_t fid;

            xfer += iprot->readStructBegin(fname);

            using ::apache::thrift::protocol::TProtocolException;


            while (true) {
                xfer += iprot->readFieldBegin(fname, ftype, fid);
                if (ftype == ::apache::thrift::protocol::T_STOP) {
                    break;
                }
                switch (fid) {
                    case 1:
                        if (ftype == ::apache::thrift::protocol::T_I32) {
                            xfer += iprot->readI32(this->min);
                            this->__isset.min = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    case 2:
                        if (ftype == ::apache::thrift::protocol::T_I32) {
                            xfer += iprot->readI32(this->max);
                            this->__isset.max = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    case 3:
                        if (ftype == ::apache::thrift::protocol::T_I32) {
                            xfer += iprot->readI32(this->start);
                            this->__isset.start = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    case 4:
                        if (ftype == ::apache::thrift::protocol::T_STRING) {
                            xfer += iprot->readString(this->quantity);
                            this->__isset.quantity = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
                }
                xfer += iprot->readFieldEnd();
            }

            xfer += iprot->readStructEnd();

            return xfer;
        }

        uint32_t EnumerationAttribute::write(::apache::thrift::protocol::TProtocol *oprot) const {
            uint32_t xfer = 0;
            ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
            xfer += oprot->writeStructBegin("EnumerationAttribute");

            xfer += oprot->writeFieldBegin("min", ::apache::thrift::protocol::T_I32, 1);
            xfer += oprot->writeI32(this->min);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldBegin("max", ::apache::thrift::protocol::T_I32, 2);
            xfer += oprot->writeI32(this->max);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldBegin("start", ::apache::thrift::protocol::T_I32, 3);
            xfer += oprot->writeI32(this->start);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldBegin("quantity", ::apache::thrift::protocol::T_STRING, 4);
            xfer += oprot->writeString(this->quantity);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldStop();
            xfer += oprot->writeStructEnd();
            return xfer;
        }

        void swap(EnumerationAttribute &a, EnumerationAttribute &b) {
            using ::std::swap;
            swap(a.min, b.min);
            swap(a.max, b.max);
            swap(a.start, b.start);
            swap(a.quantity, b.quantity);
            swap(a.__isset, b.__isset);
        }

        EnumerationAttribute::EnumerationAttribute(const EnumerationAttribute &other8) {
            min = other8.min;
            max = other8.max;
            start = other8.start;
            quantity = other8.quantity;
            __isset = other8.__isset;
        }

        EnumerationAttribute &EnumerationAttribute::operator=(const EnumerationAttribute &other9) {
            min = other9.min;
            max = other9.max;
            start = other9.start;
            quantity = other9.quantity;
            __isset = other9.__isset;
            return *this;
        }

        void EnumerationAttribute::printTo(std::ostream &out) const {
            using ::apache::thrift::to_string;
            out << "EnumerationAttribute(";
            out << "min=" << to_string(min);
            out << ", " << "max=" << to_string(max);
            out << ", " << "start=" << to_string(start);
            out << ", " << "quantity=" << to_string(quantity);
            out << ")";
        }


        ScalarVariableAttribute::~ScalarVariableAttribute() noexcept {
        }


        void ScalarVariableAttribute::__set_integerAttribute(const IntegerAttribute &val) {
            this->integerAttribute = val;
            __isset.integerAttribute = true;
        }

        void ScalarVariableAttribute::__set_realAttribute(const RealAttribute &val) {
            this->realAttribute = val;
            __isset.realAttribute = true;
        }

        void ScalarVariableAttribute::__set_stringAttribute(const StringAttribute &val) {
            this->stringAttribute = val;
            __isset.stringAttribute = true;
        }

        void ScalarVariableAttribute::__set_booleanAttribute(const BooleanAttribute &val) {
            this->booleanAttribute = val;
            __isset.booleanAttribute = true;
        }

        void ScalarVariableAttribute::__set_enumerationAttribute(const EnumerationAttribute &val) {
            this->enumerationAttribute = val;
            __isset.enumerationAttribute = true;
        }

        std::ostream &operator<<(std::ostream &out, const ScalarVariableAttribute &obj) {
            obj.printTo(out);
            return out;
        }


        uint32_t ScalarVariableAttribute::read(::apache::thrift::protocol::TProtocol *iprot) {

            ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
            uint32_t xfer = 0;
            std::string fname;
            ::apache::thrift::protocol::TType ftype;
            int16_t fid;

            xfer += iprot->readStructBegin(fname);

            using ::apache::thrift::protocol::TProtocolException;


            while (true) {
                xfer += iprot->readFieldBegin(fname, ftype, fid);
                if (ftype == ::apache::thrift::protocol::T_STOP) {
                    break;
                }
                switch (fid) {
                    case 1:
                        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                            xfer += this->integerAttribute.read(iprot);
                            this->__isset.integerAttribute = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    case 2:
                        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                            xfer += this->realAttribute.read(iprot);
                            this->__isset.realAttribute = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    case 3:
                        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                            xfer += this->stringAttribute.read(iprot);
                            this->__isset.stringAttribute = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    case 4:
                        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                            xfer += this->booleanAttribute.read(iprot);
                            this->__isset.booleanAttribute = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    case 5:
                        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                            xfer += this->enumerationAttribute.read(iprot);
                            this->__isset.enumerationAttribute = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
                }
                xfer += iprot->readFieldEnd();
            }

            xfer += iprot->readStructEnd();

            return xfer;
        }

        uint32_t ScalarVariableAttribute::write(::apache::thrift::protocol::TProtocol *oprot) const {
            uint32_t xfer = 0;
            ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
            xfer += oprot->writeStructBegin("ScalarVariableAttribute");

            if (this->__isset.integerAttribute) {
                xfer += oprot->writeFieldBegin("integerAttribute", ::apache::thrift::protocol::T_STRUCT, 1);
                xfer += this->integerAttribute.write(oprot);
                xfer += oprot->writeFieldEnd();
            }
            if (this->__isset.realAttribute) {
                xfer += oprot->writeFieldBegin("realAttribute", ::apache::thrift::protocol::T_STRUCT, 2);
                xfer += this->realAttribute.write(oprot);
                xfer += oprot->writeFieldEnd();
            }
            if (this->__isset.stringAttribute) {
                xfer += oprot->writeFieldBegin("stringAttribute", ::apache::thrift::protocol::T_STRUCT, 3);
                xfer += this->stringAttribute.write(oprot);
                xfer += oprot->writeFieldEnd();
            }
            if (this->__isset.booleanAttribute) {
                xfer += oprot->writeFieldBegin("booleanAttribute", ::apache::thrift::protocol::T_STRUCT, 4);
                xfer += this->booleanAttribute.write(oprot);
                xfer += oprot->writeFieldEnd();
            }
            if (this->__isset.enumerationAttribute) {
                xfer += oprot->writeFieldBegin("enumerationAttribute", ::apache::thrift::protocol::T_STRUCT, 5);
                xfer += this->enumerationAttribute.write(oprot);
                xfer += oprot->writeFieldEnd();
            }
            xfer += oprot->writeFieldStop();
            xfer += oprot->writeStructEnd();
            return xfer;
        }

        void swap(ScalarVariableAttribute &a, ScalarVariableAttribute &b) {
            using ::std::swap;
            swap(a.integerAttribute, b.integerAttribute);
            swap(a.realAttribute, b.realAttribute);
            swap(a.stringAttribute, b.stringAttribute);
            swap(a.booleanAttribute, b.booleanAttribute);
            swap(a.enumerationAttribute, b.enumerationAttribute);
            swap(a.__isset, b.__isset);
        }

        ScalarVariableAttribute::ScalarVariableAttribute(const ScalarVariableAttribute &other10) {
            integerAttribute = other10.integerAttribute;
            realAttribute = other10.realAttribute;
            stringAttribute = other10.stringAttribute;
            booleanAttribute = other10.booleanAttribute;
            enumerationAttribute = other10.enumerationAttribute;
            __isset = other10.__isset;
        }

        ScalarVariableAttribute &ScalarVariableAttribute::operator=(const ScalarVariableAttribute &other11) {
            integerAttribute = other11.integerAttribute;
            realAttribute = other11.realAttribute;
            stringAttribute = other11.stringAttribute;
            booleanAttribute = other11.booleanAttribute;
            enumerationAttribute = other11.enumerationAttribute;
            __isset = other11.__isset;
            return *this;
        }

        void ScalarVariableAttribute::printTo(std::ostream &out) const {
            using ::apache::thrift::to_string;
            out << "ScalarVariableAttribute(";
            out << "integerAttribute=";
            (__isset.integerAttribute ? (out << to_string(integerAttribute)) : (out << "<null>"));
            out << ", " << "realAttribute=";
            (__isset.realAttribute ? (out << to_string(realAttribute)) : (out << "<null>"));
            out << ", " << "stringAttribute=";
            (__isset.stringAttribute ? (out << to_string(stringAttribute)) : (out << "<null>"));
            out << ", " << "booleanAttribute=";
            (__isset.booleanAttribute ? (out << to_string(booleanAttribute)) : (out << "<null>"));
            out << ", " << "enumerationAttribute=";
            (__isset.enumerationAttribute ? (out << to_string(enumerationAttribute)) : (out << "<null>"));
            out << ")";
        }


        ScalarVariable::~ScalarVariable() noexcept {
        }


        void ScalarVariable::__set_name(const std::string &val) {
            this->name = val;
        }

        void ScalarVariable::__set_valueReference(const ValueReference val) {
            this->valueReference = val;
        }

        void ScalarVariable::__set_description(const std::string &val) {
            this->description = val;
            __isset.description = true;
        }

        void ScalarVariable::__set_initial(const Initial::type val) {
            this->initial = val;
            __isset.initial = true;
        }

        void ScalarVariable::__set_causality(const Causality::type val) {
            this->causality = val;
            __isset.causality = true;
        }

        void ScalarVariable::__set_variability(const Variability::type val) {
            this->variability = val;
            __isset.variability = true;
        }

        void ScalarVariable::__set_attribute(const ScalarVariableAttribute &val) {
            this->attribute = val;
        }

        std::ostream &operator<<(std::ostream &out, const ScalarVariable &obj) {
            obj.printTo(out);
            return out;
        }


        uint32_t ScalarVariable::read(::apache::thrift::protocol::TProtocol *iprot) {

            ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
            uint32_t xfer = 0;
            std::string fname;
            ::apache::thrift::protocol::TType ftype;
            int16_t fid;

            xfer += iprot->readStructBegin(fname);

            using ::apache::thrift::protocol::TProtocolException;


            while (true) {
                xfer += iprot->readFieldBegin(fname, ftype, fid);
                if (ftype == ::apache::thrift::protocol::T_STOP) {
                    break;
                }
                switch (fid) {
                    case 1:
                        if (ftype == ::apache::thrift::protocol::T_STRING) {
                            xfer += iprot->readString(this->name);
                            this->__isset.name = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    case 2:
                        if (ftype == ::apache::thrift::protocol::T_I64) {
                            xfer += iprot->readI64(this->valueReference);
                            this->__isset.valueReference = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    case 3:
                        if (ftype == ::apache::thrift::protocol::T_STRING) {
                            xfer += iprot->readString(this->description);
                            this->__isset.description = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    case 4:
                        if (ftype == ::apache::thrift::protocol::T_I32) {
                            int32_t ecast12;
                            xfer += iprot->readI32(ecast12);
                            this->initial = (Initial::type) ecast12;
                            this->__isset.initial = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    case 5:
                        if (ftype == ::apache::thrift::protocol::T_I32) {
                            int32_t ecast13;
                            xfer += iprot->readI32(ecast13);
                            this->causality = (Causality::type) ecast13;
                            this->__isset.causality = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    case 6:
                        if (ftype == ::apache::thrift::protocol::T_I32) {
                            int32_t ecast14;
                            xfer += iprot->readI32(ecast14);
                            this->variability = (Variability::type) ecast14;
                            this->__isset.variability = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    case 7:
                        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                            xfer += this->attribute.read(iprot);
                            this->__isset.attribute = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
                }
                xfer += iprot->readFieldEnd();
            }

            xfer += iprot->readStructEnd();

            return xfer;
        }

        uint32_t ScalarVariable::write(::apache::thrift::protocol::TProtocol *oprot) const {
            uint32_t xfer = 0;
            ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
            xfer += oprot->writeStructBegin("ScalarVariable");

            xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
            xfer += oprot->writeString(this->name);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldBegin("valueReference", ::apache::thrift::protocol::T_I64, 2);
            xfer += oprot->writeI64(this->valueReference);
            xfer += oprot->writeFieldEnd();

            if (this->__isset.description) {
                xfer += oprot->writeFieldBegin("description", ::apache::thrift::protocol::T_STRING, 3);
                xfer += oprot->writeString(this->description);
                xfer += oprot->writeFieldEnd();
            }
            if (this->__isset.initial) {
                xfer += oprot->writeFieldBegin("initial", ::apache::thrift::protocol::T_I32, 4);
                xfer += oprot->writeI32((int32_t) this->initial);
                xfer += oprot->writeFieldEnd();
            }
            if (this->__isset.causality) {
                xfer += oprot->writeFieldBegin("causality", ::apache::thrift::protocol::T_I32, 5);
                xfer += oprot->writeI32((int32_t) this->causality);
                xfer += oprot->writeFieldEnd();
            }
            if (this->__isset.variability) {
                xfer += oprot->writeFieldBegin("variability", ::apache::thrift::protocol::T_I32, 6);
                xfer += oprot->writeI32((int32_t) this->variability);
                xfer += oprot->writeFieldEnd();
            }
            xfer += oprot->writeFieldBegin("attribute", ::apache::thrift::protocol::T_STRUCT, 7);
            xfer += this->attribute.write(oprot);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldStop();
            xfer += oprot->writeStructEnd();
            return xfer;
        }

        void swap(ScalarVariable &a, ScalarVariable &b) {
            using ::std::swap;
            swap(a.name, b.name);
            swap(a.valueReference, b.valueReference);
            swap(a.description, b.description);
            swap(a.initial, b.initial);
            swap(a.causality, b.causality);
            swap(a.variability, b.variability);
            swap(a.attribute, b.attribute);
            swap(a.__isset, b.__isset);
        }

        ScalarVariable::ScalarVariable(const ScalarVariable &other15) {
            name = other15.name;
            valueReference = other15.valueReference;
            description = other15.description;
            initial = other15.initial;
            causality = other15.causality;
            variability = other15.variability;
            attribute = other15.attribute;
            __isset = other15.__isset;
        }

        ScalarVariable &ScalarVariable::operator=(const ScalarVariable &other16) {
            name = other16.name;
            valueReference = other16.valueReference;
            description = other16.description;
            initial = other16.initial;
            causality = other16.causality;
            variability = other16.variability;
            attribute = other16.attribute;
            __isset = other16.__isset;
            return *this;
        }

        void ScalarVariable::printTo(std::ostream &out) const {
            using ::apache::thrift::to_string;
            out << "ScalarVariable(";
            out << "name=" << to_string(name);
            out << ", " << "valueReference=" << to_string(valueReference);
            out << ", " << "description=";
            (__isset.description ? (out << to_string(description)) : (out << "<null>"));
            out << ", " << "initial=";
            (__isset.initial ? (out << to_string(initial)) : (out << "<null>"));
            out << ", " << "causality=";
            (__isset.causality ? (out << to_string(causality)) : (out << "<null>"));
            out << ", " << "variability=";
            (__isset.variability ? (out << to_string(variability)) : (out << "<null>"));
            out << ", " << "attribute=" << to_string(attribute);
            out << ")";
        }


        Unknown::~Unknown() noexcept {
        }


        void Unknown::__set_index(const int32_t val) {
            this->index = val;
        }

        void Unknown::__set_dependencies(const std::vector<int32_t> &val) {
            this->dependencies = val;
        }

        void Unknown::__set_dependenciesKind(const std::string &val) {
            this->dependenciesKind = val;
        }

        std::ostream &operator<<(std::ostream &out, const Unknown &obj) {
            obj.printTo(out);
            return out;
        }


        uint32_t Unknown::read(::apache::thrift::protocol::TProtocol *iprot) {

            ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
            uint32_t xfer = 0;
            std::string fname;
            ::apache::thrift::protocol::TType ftype;
            int16_t fid;

            xfer += iprot->readStructBegin(fname);

            using ::apache::thrift::protocol::TProtocolException;


            while (true) {
                xfer += iprot->readFieldBegin(fname, ftype, fid);
                if (ftype == ::apache::thrift::protocol::T_STOP) {
                    break;
                }
                switch (fid) {
                    case 1:
                        if (ftype == ::apache::thrift::protocol::T_I32) {
                            xfer += iprot->readI32(this->index);
                            this->__isset.index = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    case 2:
                        if (ftype == ::apache::thrift::protocol::T_LIST) {
                            {
                                this->dependencies.clear();
                                uint32_t _size17;
                                ::apache::thrift::protocol::TType _etype20;
                                xfer += iprot->readListBegin(_etype20, _size17);
                                this->dependencies.resize(_size17);
                                uint32_t _i21;
                                for (_i21 = 0; _i21 < _size17; ++_i21) {
                                    xfer += iprot->readI32(this->dependencies[_i21]);
                                }
                                xfer += iprot->readListEnd();
                            }
                            this->__isset.dependencies = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    case 3:
                        if (ftype == ::apache::thrift::protocol::T_STRING) {
                            xfer += iprot->readString(this->dependenciesKind);
                            this->__isset.dependenciesKind = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
                }
                xfer += iprot->readFieldEnd();
            }

            xfer += iprot->readStructEnd();

            return xfer;
        }

        uint32_t Unknown::write(::apache::thrift::protocol::TProtocol *oprot) const {
            uint32_t xfer = 0;
            ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
            xfer += oprot->writeStructBegin("Unknown");

            xfer += oprot->writeFieldBegin("index", ::apache::thrift::protocol::T_I32, 1);
            xfer += oprot->writeI32(this->index);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldBegin("dependencies", ::apache::thrift::protocol::T_LIST, 2);
            {
                xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32,
                                              static_cast<uint32_t>(this->dependencies.size()));
                std::vector<int32_t>::const_iterator _iter22;
                for (_iter22 = this->dependencies.begin(); _iter22 != this->dependencies.end(); ++_iter22) {
                    xfer += oprot->writeI32((*_iter22));
                }
                xfer += oprot->writeListEnd();
            }
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldBegin("dependenciesKind", ::apache::thrift::protocol::T_STRING, 3);
            xfer += oprot->writeString(this->dependenciesKind);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldStop();
            xfer += oprot->writeStructEnd();
            return xfer;
        }

        void swap(Unknown &a, Unknown &b) {
            using ::std::swap;
            swap(a.index, b.index);
            swap(a.dependencies, b.dependencies);
            swap(a.dependenciesKind, b.dependenciesKind);
            swap(a.__isset, b.__isset);
        }

        Unknown::Unknown(const Unknown &other23) {
            index = other23.index;
            dependencies = other23.dependencies;
            dependenciesKind = other23.dependenciesKind;
            __isset = other23.__isset;
        }

        Unknown &Unknown::operator=(const Unknown &other24) {
            index = other24.index;
            dependencies = other24.dependencies;
            dependenciesKind = other24.dependenciesKind;
            __isset = other24.__isset;
            return *this;
        }

        void Unknown::printTo(std::ostream &out) const {
            using ::apache::thrift::to_string;
            out << "Unknown(";
            out << "index=" << to_string(index);
            out << ", " << "dependencies=" << to_string(dependencies);
            out << ", " << "dependenciesKind=" << to_string(dependenciesKind);
            out << ")";
        }


        ModelStructure::~ModelStructure() noexcept {
        }


        void ModelStructure::__set_outputs(const std::vector<Unknown> &val) {
            this->outputs = val;
        }

        void ModelStructure::__set_derivatives(const std::vector<Unknown> &val) {
            this->derivatives = val;
        }

        void ModelStructure::__set_initialUnknowns(const std::vector<Unknown> &val) {
            this->initialUnknowns = val;
        }

        std::ostream &operator<<(std::ostream &out, const ModelStructure &obj) {
            obj.printTo(out);
            return out;
        }


        uint32_t ModelStructure::read(::apache::thrift::protocol::TProtocol *iprot) {

            ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
            uint32_t xfer = 0;
            std::string fname;
            ::apache::thrift::protocol::TType ftype;
            int16_t fid;

            xfer += iprot->readStructBegin(fname);

            using ::apache::thrift::protocol::TProtocolException;


            while (true) {
                xfer += iprot->readFieldBegin(fname, ftype, fid);
                if (ftype == ::apache::thrift::protocol::T_STOP) {
                    break;
                }
                switch (fid) {
                    case 1:
                        if (ftype == ::apache::thrift::protocol::T_LIST) {
                            {
                                this->outputs.clear();
                                uint32_t _size25;
                                ::apache::thrift::protocol::TType _etype28;
                                xfer += iprot->readListBegin(_etype28, _size25);
                                this->outputs.resize(_size25);
                                uint32_t _i29;
                                for (_i29 = 0; _i29 < _size25; ++_i29) {
                                    xfer += this->outputs[_i29].read(iprot);
                                }
                                xfer += iprot->readListEnd();
                            }
                            this->__isset.outputs = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    case 2:
                        if (ftype == ::apache::thrift::protocol::T_LIST) {
                            {
                                this->derivatives.clear();
                                uint32_t _size30;
                                ::apache::thrift::protocol::TType _etype33;
                                xfer += iprot->readListBegin(_etype33, _size30);
                                this->derivatives.resize(_size30);
                                uint32_t _i34;
                                for (_i34 = 0; _i34 < _size30; ++_i34) {
                                    xfer += this->derivatives[_i34].read(iprot);
                                }
                                xfer += iprot->readListEnd();
                            }
                            this->__isset.derivatives = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    case 3:
                        if (ftype == ::apache::thrift::protocol::T_LIST) {
                            {
                                this->initialUnknowns.clear();
                                uint32_t _size35;
                                ::apache::thrift::protocol::TType _etype38;
                                xfer += iprot->readListBegin(_etype38, _size35);
                                this->initialUnknowns.resize(_size35);
                                uint32_t _i39;
                                for (_i39 = 0; _i39 < _size35; ++_i39) {
                                    xfer += this->initialUnknowns[_i39].read(iprot);
                                }
                                xfer += iprot->readListEnd();
                            }
                            this->__isset.initialUnknowns = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
                }
                xfer += iprot->readFieldEnd();
            }

            xfer += iprot->readStructEnd();

            return xfer;
        }

        uint32_t ModelStructure::write(::apache::thrift::protocol::TProtocol *oprot) const {
            uint32_t xfer = 0;
            ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
            xfer += oprot->writeStructBegin("ModelStructure");

            xfer += oprot->writeFieldBegin("outputs", ::apache::thrift::protocol::T_LIST, 1);
            {
                xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT,
                                              static_cast<uint32_t>(this->outputs.size()));
                std::vector<Unknown>::const_iterator _iter40;
                for (_iter40 = this->outputs.begin(); _iter40 != this->outputs.end(); ++_iter40) {
                    xfer += (*_iter40).write(oprot);
                }
                xfer += oprot->writeListEnd();
            }
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldBegin("derivatives", ::apache::thrift::protocol::T_LIST, 2);
            {
                xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT,
                                              static_cast<uint32_t>(this->derivatives.size()));
                std::vector<Unknown>::const_iterator _iter41;
                for (_iter41 = this->derivatives.begin(); _iter41 != this->derivatives.end(); ++_iter41) {
                    xfer += (*_iter41).write(oprot);
                }
                xfer += oprot->writeListEnd();
            }
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldBegin("initialUnknowns", ::apache::thrift::protocol::T_LIST, 3);
            {
                xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT,
                                              static_cast<uint32_t>(this->initialUnknowns.size()));
                std::vector<Unknown>::const_iterator _iter42;
                for (_iter42 = this->initialUnknowns.begin(); _iter42 != this->initialUnknowns.end(); ++_iter42) {
                    xfer += (*_iter42).write(oprot);
                }
                xfer += oprot->writeListEnd();
            }
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldStop();
            xfer += oprot->writeStructEnd();
            return xfer;
        }

        void swap(ModelStructure &a, ModelStructure &b) {
            using ::std::swap;
            swap(a.outputs, b.outputs);
            swap(a.derivatives, b.derivatives);
            swap(a.initialUnknowns, b.initialUnknowns);
            swap(a.__isset, b.__isset);
        }

        ModelStructure::ModelStructure(const ModelStructure &other43) {
            outputs = other43.outputs;
            derivatives = other43.derivatives;
            initialUnknowns = other43.initialUnknowns;
            __isset = other43.__isset;
        }

        ModelStructure &ModelStructure::operator=(const ModelStructure &other44) {
            outputs = other44.outputs;
            derivatives = other44.derivatives;
            initialUnknowns = other44.initialUnknowns;
            __isset = other44.__isset;
            return *this;
        }

        void ModelStructure::printTo(std::ostream &out) const {
            using ::apache::thrift::to_string;
            out << "ModelStructure(";
            out << "outputs=" << to_string(outputs);
            out << ", " << "derivatives=" << to_string(derivatives);
            out << ", " << "initialUnknowns=" << to_string(initialUnknowns);
            out << ")";
        }


        DefaultExperiment::~DefaultExperiment() noexcept {
        }


        void DefaultExperiment::__set_startTime(const double val) {
            this->startTime = val;
        }

        void DefaultExperiment::__set_stopTime(const double val) {
            this->stopTime = val;
        }

        void DefaultExperiment::__set_tolerance(const double val) {
            this->tolerance = val;
        }

        void DefaultExperiment::__set_stepSize(const double val) {
            this->stepSize = val;
        }

        std::ostream &operator<<(std::ostream &out, const DefaultExperiment &obj) {
            obj.printTo(out);
            return out;
        }


        uint32_t DefaultExperiment::read(::apache::thrift::protocol::TProtocol *iprot) {

            ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
            uint32_t xfer = 0;
            std::string fname;
            ::apache::thrift::protocol::TType ftype;
            int16_t fid;

            xfer += iprot->readStructBegin(fname);

            using ::apache::thrift::protocol::TProtocolException;


            while (true) {
                xfer += iprot->readFieldBegin(fname, ftype, fid);
                if (ftype == ::apache::thrift::protocol::T_STOP) {
                    break;
                }
                switch (fid) {
                    case 1:
                        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
                            xfer += iprot->readDouble(this->startTime);
                            this->__isset.startTime = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    case 2:
                        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
                            xfer += iprot->readDouble(this->stopTime);
                            this->__isset.stopTime = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    case 3:
                        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
                            xfer += iprot->readDouble(this->tolerance);
                            this->__isset.tolerance = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    case 4:
                        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
                            xfer += iprot->readDouble(this->stepSize);
                            this->__isset.stepSize = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
                }
                xfer += iprot->readFieldEnd();
            }

            xfer += iprot->readStructEnd();

            return xfer;
        }

        uint32_t DefaultExperiment::write(::apache::thrift::protocol::TProtocol *oprot) const {
            uint32_t xfer = 0;
            ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
            xfer += oprot->writeStructBegin("DefaultExperiment");

            xfer += oprot->writeFieldBegin("startTime", ::apache::thrift::protocol::T_DOUBLE, 1);
            xfer += oprot->writeDouble(this->startTime);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldBegin("stopTime", ::apache::thrift::protocol::T_DOUBLE, 2);
            xfer += oprot->writeDouble(this->stopTime);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldBegin("tolerance", ::apache::thrift::protocol::T_DOUBLE, 3);
            xfer += oprot->writeDouble(this->tolerance);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldBegin("stepSize", ::apache::thrift::protocol::T_DOUBLE, 4);
            xfer += oprot->writeDouble(this->stepSize);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldStop();
            xfer += oprot->writeStructEnd();
            return xfer;
        }

        void swap(DefaultExperiment &a, DefaultExperiment &b) {
            using ::std::swap;
            swap(a.startTime, b.startTime);
            swap(a.stopTime, b.stopTime);
            swap(a.tolerance, b.tolerance);
            swap(a.stepSize, b.stepSize);
            swap(a.__isset, b.__isset);
        }

        DefaultExperiment::DefaultExperiment(const DefaultExperiment &other45) {
            startTime = other45.startTime;
            stopTime = other45.stopTime;
            tolerance = other45.tolerance;
            stepSize = other45.stepSize;
            __isset = other45.__isset;
        }

        DefaultExperiment &DefaultExperiment::operator=(const DefaultExperiment &other46) {
            startTime = other46.startTime;
            stopTime = other46.stopTime;
            tolerance = other46.tolerance;
            stepSize = other46.stepSize;
            __isset = other46.__isset;
            return *this;
        }

        void DefaultExperiment::printTo(std::ostream &out) const {
            using ::apache::thrift::to_string;
            out << "DefaultExperiment(";
            out << "startTime=" << to_string(startTime);
            out << ", " << "stopTime=" << to_string(stopTime);
            out << ", " << "tolerance=" << to_string(tolerance);
            out << ", " << "stepSize=" << to_string(stepSize);
            out << ")";
        }


        StepResult::~StepResult() noexcept {
        }


        void StepResult::__set_status(const Status::type val) {
            this->status = val;
        }

        void StepResult::__set_simulationTime(const double val) {
            this->simulationTime = val;
        }

        std::ostream &operator<<(std::ostream &out, const StepResult &obj) {
            obj.printTo(out);
            return out;
        }


        uint32_t StepResult::read(::apache::thrift::protocol::TProtocol *iprot) {

            ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
            uint32_t xfer = 0;
            std::string fname;
            ::apache::thrift::protocol::TType ftype;
            int16_t fid;

            xfer += iprot->readStructBegin(fname);

            using ::apache::thrift::protocol::TProtocolException;


            while (true) {
                xfer += iprot->readFieldBegin(fname, ftype, fid);
                if (ftype == ::apache::thrift::protocol::T_STOP) {
                    break;
                }
                switch (fid) {
                    case 1:
                        if (ftype == ::apache::thrift::protocol::T_I32) {
                            int32_t ecast47;
                            xfer += iprot->readI32(ecast47);
                            this->status = (Status::type) ecast47;
                            this->__isset.status = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    case 2:
                        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
                            xfer += iprot->readDouble(this->simulationTime);
                            this->__isset.simulationTime = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
                }
                xfer += iprot->readFieldEnd();
            }

            xfer += iprot->readStructEnd();

            return xfer;
        }

        uint32_t StepResult::write(::apache::thrift::protocol::TProtocol *oprot) const {
            uint32_t xfer = 0;
            ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
            xfer += oprot->writeStructBegin("StepResult");

            xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 1);
            xfer += oprot->writeI32((int32_t) this->status);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldBegin("simulationTime", ::apache::thrift::protocol::T_DOUBLE, 2);
            xfer += oprot->writeDouble(this->simulationTime);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldStop();
            xfer += oprot->writeStructEnd();
            return xfer;
        }

        void swap(StepResult &a, StepResult &b) {
            using ::std::swap;
            swap(a.status, b.status);
            swap(a.simulationTime, b.simulationTime);
            swap(a.__isset, b.__isset);
        }

        StepResult::StepResult(const StepResult &other48) {
            status = other48.status;
            simulationTime = other48.simulationTime;
            __isset = other48.__isset;
        }

        StepResult &StepResult::operator=(const StepResult &other49) {
            status = other49.status;
            simulationTime = other49.simulationTime;
            __isset = other49.__isset;
            return *this;
        }

        void StepResult::printTo(std::ostream &out) const {
            using ::apache::thrift::to_string;
            out << "StepResult(";
            out << "status=" << to_string(status);
            out << ", " << "simulationTime=" << to_string(simulationTime);
            out << ")";
        }


        IntegerRead::~IntegerRead() noexcept {
        }


        void IntegerRead::__set_value(const std::vector<int32_t> &val) {
            this->value = val;
        }

        void IntegerRead::__set_status(const Status::type val) {
            this->status = val;
        }

        std::ostream &operator<<(std::ostream &out, const IntegerRead &obj) {
            obj.printTo(out);
            return out;
        }


        uint32_t IntegerRead::read(::apache::thrift::protocol::TProtocol *iprot) {

            ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
            uint32_t xfer = 0;
            std::string fname;
            ::apache::thrift::protocol::TType ftype;
            int16_t fid;

            xfer += iprot->readStructBegin(fname);

            using ::apache::thrift::protocol::TProtocolException;


            while (true) {
                xfer += iprot->readFieldBegin(fname, ftype, fid);
                if (ftype == ::apache::thrift::protocol::T_STOP) {
                    break;
                }
                switch (fid) {
                    case 1:
                        if (ftype == ::apache::thrift::protocol::T_LIST) {
                            {
                                this->value.clear();
                                uint32_t _size50;
                                ::apache::thrift::protocol::TType _etype53;
                                xfer += iprot->readListBegin(_etype53, _size50);
                                this->value.resize(_size50);
                                uint32_t _i54;
                                for (_i54 = 0; _i54 < _size50; ++_i54) {
                                    xfer += iprot->readI32(this->value[_i54]);
                                }
                                xfer += iprot->readListEnd();
                            }
                            this->__isset.value = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    case 2:
                        if (ftype == ::apache::thrift::protocol::T_I32) {
                            int32_t ecast55;
                            xfer += iprot->readI32(ecast55);
                            this->status = (Status::type) ecast55;
                            this->__isset.status = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
                }
                xfer += iprot->readFieldEnd();
            }

            xfer += iprot->readStructEnd();

            return xfer;
        }

        uint32_t IntegerRead::write(::apache::thrift::protocol::TProtocol *oprot) const {
            uint32_t xfer = 0;
            ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
            xfer += oprot->writeStructBegin("IntegerRead");

            xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_LIST, 1);
            {
                xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32,
                                              static_cast<uint32_t>(this->value.size()));
                std::vector<int32_t>::const_iterator _iter56;
                for (_iter56 = this->value.begin(); _iter56 != this->value.end(); ++_iter56) {
                    xfer += oprot->writeI32((*_iter56));
                }
                xfer += oprot->writeListEnd();
            }
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 2);
            xfer += oprot->writeI32((int32_t) this->status);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldStop();
            xfer += oprot->writeStructEnd();
            return xfer;
        }

        void swap(IntegerRead &a, IntegerRead &b) {
            using ::std::swap;
            swap(a.value, b.value);
            swap(a.status, b.status);
            swap(a.__isset, b.__isset);
        }

        IntegerRead::IntegerRead(const IntegerRead &other57) {
            value = other57.value;
            status = other57.status;
            __isset = other57.__isset;
        }

        IntegerRead &IntegerRead::operator=(const IntegerRead &other58) {
            value = other58.value;
            status = other58.status;
            __isset = other58.__isset;
            return *this;
        }

        void IntegerRead::printTo(std::ostream &out) const {
            using ::apache::thrift::to_string;
            out << "IntegerRead(";
            out << "value=" << to_string(value);
            out << ", " << "status=" << to_string(status);
            out << ")";
        }


        RealRead::~RealRead() noexcept {
        }


        void RealRead::__set_value(const std::vector<double> &val) {
            this->value = val;
        }

        void RealRead::__set_status(const Status::type val) {
            this->status = val;
        }

        std::ostream &operator<<(std::ostream &out, const RealRead &obj) {
            obj.printTo(out);
            return out;
        }


        uint32_t RealRead::read(::apache::thrift::protocol::TProtocol *iprot) {

            ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
            uint32_t xfer = 0;
            std::string fname;
            ::apache::thrift::protocol::TType ftype;
            int16_t fid;

            xfer += iprot->readStructBegin(fname);

            using ::apache::thrift::protocol::TProtocolException;


            while (true) {
                xfer += iprot->readFieldBegin(fname, ftype, fid);
                if (ftype == ::apache::thrift::protocol::T_STOP) {
                    break;
                }
                switch (fid) {
                    case 1:
                        if (ftype == ::apache::thrift::protocol::T_LIST) {
                            {
                                this->value.clear();
                                uint32_t _size59;
                                ::apache::thrift::protocol::TType _etype62;
                                xfer += iprot->readListBegin(_etype62, _size59);
                                this->value.resize(_size59);
                                uint32_t _i63;
                                for (_i63 = 0; _i63 < _size59; ++_i63) {
                                    xfer += iprot->readDouble(this->value[_i63]);
                                }
                                xfer += iprot->readListEnd();
                            }
                            this->__isset.value = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    case 2:
                        if (ftype == ::apache::thrift::protocol::T_I32) {
                            int32_t ecast64;
                            xfer += iprot->readI32(ecast64);
                            this->status = (Status::type) ecast64;
                            this->__isset.status = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
                }
                xfer += iprot->readFieldEnd();
            }

            xfer += iprot->readStructEnd();

            return xfer;
        }

        uint32_t RealRead::write(::apache::thrift::protocol::TProtocol *oprot) const {
            uint32_t xfer = 0;
            ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
            xfer += oprot->writeStructBegin("RealRead");

            xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_LIST, 1);
            {
                xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE,
                                              static_cast<uint32_t>(this->value.size()));
                std::vector<double>::const_iterator _iter65;
                for (_iter65 = this->value.begin(); _iter65 != this->value.end(); ++_iter65) {
                    xfer += oprot->writeDouble((*_iter65));
                }
                xfer += oprot->writeListEnd();
            }
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 2);
            xfer += oprot->writeI32((int32_t) this->status);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldStop();
            xfer += oprot->writeStructEnd();
            return xfer;
        }

        void swap(RealRead &a, RealRead &b) {
            using ::std::swap;
            swap(a.value, b.value);
            swap(a.status, b.status);
            swap(a.__isset, b.__isset);
        }

        RealRead::RealRead(const RealRead &other66) {
            value = other66.value;
            status = other66.status;
            __isset = other66.__isset;
        }

        RealRead &RealRead::operator=(const RealRead &other67) {
            value = other67.value;
            status = other67.status;
            __isset = other67.__isset;
            return *this;
        }

        void RealRead::printTo(std::ostream &out) const {
            using ::apache::thrift::to_string;
            out << "RealRead(";
            out << "value=" << to_string(value);
            out << ", " << "status=" << to_string(status);
            out << ")";
        }


        StringRead::~StringRead() noexcept {
        }


        void StringRead::__set_value(const std::vector<std::string> &val) {
            this->value = val;
        }

        void StringRead::__set_status(const Status::type val) {
            this->status = val;
        }

        std::ostream &operator<<(std::ostream &out, const StringRead &obj) {
            obj.printTo(out);
            return out;
        }


        uint32_t StringRead::read(::apache::thrift::protocol::TProtocol *iprot) {

            ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
            uint32_t xfer = 0;
            std::string fname;
            ::apache::thrift::protocol::TType ftype;
            int16_t fid;

            xfer += iprot->readStructBegin(fname);

            using ::apache::thrift::protocol::TProtocolException;


            while (true) {
                xfer += iprot->readFieldBegin(fname, ftype, fid);
                if (ftype == ::apache::thrift::protocol::T_STOP) {
                    break;
                }
                switch (fid) {
                    case 1:
                        if (ftype == ::apache::thrift::protocol::T_LIST) {
                            {
                                this->value.clear();
                                uint32_t _size68;
                                ::apache::thrift::protocol::TType _etype71;
                                xfer += iprot->readListBegin(_etype71, _size68);
                                this->value.resize(_size68);
                                uint32_t _i72;
                                for (_i72 = 0; _i72 < _size68; ++_i72) {
                                    xfer += iprot->readString(this->value[_i72]);
                                }
                                xfer += iprot->readListEnd();
                            }
                            this->__isset.value = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    case 2:
                        if (ftype == ::apache::thrift::protocol::T_I32) {
                            int32_t ecast73;
                            xfer += iprot->readI32(ecast73);
                            this->status = (Status::type) ecast73;
                            this->__isset.status = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
                }
                xfer += iprot->readFieldEnd();
            }

            xfer += iprot->readStructEnd();

            return xfer;
        }

        uint32_t StringRead::write(::apache::thrift::protocol::TProtocol *oprot) const {
            uint32_t xfer = 0;
            ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
            xfer += oprot->writeStructBegin("StringRead");

            xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_LIST, 1);
            {
                xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING,
                                              static_cast<uint32_t>(this->value.size()));
                std::vector<std::string>::const_iterator _iter74;
                for (_iter74 = this->value.begin(); _iter74 != this->value.end(); ++_iter74) {
                    xfer += oprot->writeString((*_iter74));
                }
                xfer += oprot->writeListEnd();
            }
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 2);
            xfer += oprot->writeI32((int32_t) this->status);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldStop();
            xfer += oprot->writeStructEnd();
            return xfer;
        }

        void swap(StringRead &a, StringRead &b) {
            using ::std::swap;
            swap(a.value, b.value);
            swap(a.status, b.status);
            swap(a.__isset, b.__isset);
        }

        StringRead::StringRead(const StringRead &other75) {
            value = other75.value;
            status = other75.status;
            __isset = other75.__isset;
        }

        StringRead &StringRead::operator=(const StringRead &other76) {
            value = other76.value;
            status = other76.status;
            __isset = other76.__isset;
            return *this;
        }

        void StringRead::printTo(std::ostream &out) const {
            using ::apache::thrift::to_string;
            out << "StringRead(";
            out << "value=" << to_string(value);
            out << ", " << "status=" << to_string(status);
            out << ")";
        }


        BooleanRead::~BooleanRead() noexcept {
        }


        void BooleanRead::__set_value(const std::vector<bool> &val) {
            this->value = val;
        }

        void BooleanRead::__set_status(const Status::type val) {
            this->status = val;
        }

        std::ostream &operator<<(std::ostream &out, const BooleanRead &obj) {
            obj.printTo(out);
            return out;
        }


        uint32_t BooleanRead::read(::apache::thrift::protocol::TProtocol *iprot) {

            ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
            uint32_t xfer = 0;
            std::string fname;
            ::apache::thrift::protocol::TType ftype;
            int16_t fid;

            xfer += iprot->readStructBegin(fname);

            using ::apache::thrift::protocol::TProtocolException;


            while (true) {
                xfer += iprot->readFieldBegin(fname, ftype, fid);
                if (ftype == ::apache::thrift::protocol::T_STOP) {
                    break;
                }
                switch (fid) {
                    case 1:
                        if (ftype == ::apache::thrift::protocol::T_LIST) {
                            {
                                this->value.clear();
                                uint32_t _size77;
                                ::apache::thrift::protocol::TType _etype80;
                                xfer += iprot->readListBegin(_etype80, _size77);
                                this->value.resize(_size77);
                                uint32_t _i81;
                                for (_i81 = 0; _i81 < _size77; ++_i81) {
                                    xfer += iprot->readBool(this->value[_i81]);
                                }
                                xfer += iprot->readListEnd();
                            }
                            this->__isset.value = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    case 2:
                        if (ftype == ::apache::thrift::protocol::T_I32) {
                            int32_t ecast82;
                            xfer += iprot->readI32(ecast82);
                            this->status = (Status::type) ecast82;
                            this->__isset.status = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
                }
                xfer += iprot->readFieldEnd();
            }

            xfer += iprot->readStructEnd();

            return xfer;
        }

        uint32_t BooleanRead::write(::apache::thrift::protocol::TProtocol *oprot) const {
            uint32_t xfer = 0;
            ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
            xfer += oprot->writeStructBegin("BooleanRead");

            xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_LIST, 1);
            {
                xfer += oprot->writeListBegin(::apache::thrift::protocol::T_BOOL,
                                              static_cast<uint32_t>(this->value.size()));
                std::vector<bool>::const_iterator _iter83;
                for (_iter83 = this->value.begin(); _iter83 != this->value.end(); ++_iter83) {
                    xfer += oprot->writeBool((*_iter83));
                }
                xfer += oprot->writeListEnd();
            }
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 2);
            xfer += oprot->writeI32((int32_t) this->status);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldStop();
            xfer += oprot->writeStructEnd();
            return xfer;
        }

        void swap(BooleanRead &a, BooleanRead &b) {
            using ::std::swap;
            swap(a.value, b.value);
            swap(a.status, b.status);
            swap(a.__isset, b.__isset);
        }

        BooleanRead::BooleanRead(const BooleanRead &other84) {
            value = other84.value;
            status = other84.status;
            __isset = other84.__isset;
        }

        BooleanRead &BooleanRead::operator=(const BooleanRead &other85) {
            value = other85.value;
            status = other85.status;
            __isset = other85.__isset;
            return *this;
        }

        void BooleanRead::printTo(std::ostream &out) const {
            using ::apache::thrift::to_string;
            out << "BooleanRead(";
            out << "value=" << to_string(value);
            out << ", " << "status=" << to_string(status);
            out << ")";
        }


        Solver::~Solver() noexcept {
        }


        void Solver::__set_name(const std::string &val) {
            this->name = val;
        }

        void Solver::__set_settings(const std::string &val) {
            this->settings = val;
        }

        std::ostream &operator<<(std::ostream &out, const Solver &obj) {
            obj.printTo(out);
            return out;
        }


        uint32_t Solver::read(::apache::thrift::protocol::TProtocol *iprot) {

            ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
            uint32_t xfer = 0;
            std::string fname;
            ::apache::thrift::protocol::TType ftype;
            int16_t fid;

            xfer += iprot->readStructBegin(fname);

            using ::apache::thrift::protocol::TProtocolException;


            while (true) {
                xfer += iprot->readFieldBegin(fname, ftype, fid);
                if (ftype == ::apache::thrift::protocol::T_STOP) {
                    break;
                }
                switch (fid) {
                    case 1:
                        if (ftype == ::apache::thrift::protocol::T_STRING) {
                            xfer += iprot->readString(this->name);
                            this->__isset.name = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    case 2:
                        if (ftype == ::apache::thrift::protocol::T_STRING) {
                            xfer += iprot->readString(this->settings);
                            this->__isset.settings = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
                }
                xfer += iprot->readFieldEnd();
            }

            xfer += iprot->readStructEnd();

            return xfer;
        }

        uint32_t Solver::write(::apache::thrift::protocol::TProtocol *oprot) const {
            uint32_t xfer = 0;
            ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
            xfer += oprot->writeStructBegin("Solver");

            xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
            xfer += oprot->writeString(this->name);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldBegin("settings", ::apache::thrift::protocol::T_STRING, 2);
            xfer += oprot->writeString(this->settings);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldStop();
            xfer += oprot->writeStructEnd();
            return xfer;
        }

        void swap(Solver &a, Solver &b) {
            using ::std::swap;
            swap(a.name, b.name);
            swap(a.settings, b.settings);
            swap(a.__isset, b.__isset);
        }

        Solver::Solver(const Solver &other86) {
            name = other86.name;
            settings = other86.settings;
            __isset = other86.__isset;
        }

        Solver &Solver::operator=(const Solver &other87) {
            name = other87.name;
            settings = other87.settings;
            __isset = other87.__isset;
            return *this;
        }

        void Solver::printTo(std::ostream &out) const {
            using ::apache::thrift::to_string;
            out << "Solver(";
            out << "name=" << to_string(name);
            out << ", " << "settings=" << to_string(settings);
            out << ")";
        }


        ModelDescription::~ModelDescription() noexcept {
        }


        void ModelDescription::__set_guid(const std::string &val) {
            this->guid = val;
        }

        void ModelDescription::__set_fmiVersion(const std::string &val) {
            this->fmiVersion = val;
        }

        void ModelDescription::__set_modelName(const std::string &val) {
            this->modelName = val;
        }

        void ModelDescription::__set_license(const std::string &val) {
            this->license = val;
            __isset.license = true;
        }

        void ModelDescription::__set_copyright(const std::string &val) {
            this->copyright = val;
            __isset.copyright = true;
        }

        void ModelDescription::__set_author(const std::string &val) {
            this->author = val;
            __isset.author = true;
        }

        void ModelDescription::__set_version(const std::string &val) {
            this->version = val;
            __isset.version = true;
        }

        void ModelDescription::__set_description(const std::string &val) {
            this->description = val;
            __isset.description = true;
        }

        void ModelDescription::__set_generationTool(const std::string &val) {
            this->generationTool = val;
            __isset.generationTool = true;
        }

        void ModelDescription::__set_generationDateAndTime(const std::string &val) {
            this->generationDateAndTime = val;
            __isset.generationDateAndTime = true;
        }

        void ModelDescription::__set_defaultExperiment(const DefaultExperiment &val) {
            this->defaultExperiment = val;
            __isset.defaultExperiment = true;
        }

        void ModelDescription::__set_variableNamingConvention(const std::string &val) {
            this->variableNamingConvention = val;
            __isset.variableNamingConvention = true;
        }

        void ModelDescription::__set_modelVariables(const ModelVariables &val) {
            this->modelVariables = val;
        }

        void ModelDescription::__set_modelStructure(const ModelStructure &val) {
            this->modelStructure = val;
        }

        std::ostream &operator<<(std::ostream &out, const ModelDescription &obj) {
            obj.printTo(out);
            return out;
        }


        uint32_t ModelDescription::read(::apache::thrift::protocol::TProtocol *iprot) {

            ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
            uint32_t xfer = 0;
            std::string fname;
            ::apache::thrift::protocol::TType ftype;
            int16_t fid;

            xfer += iprot->readStructBegin(fname);

            using ::apache::thrift::protocol::TProtocolException;


            while (true) {
                xfer += iprot->readFieldBegin(fname, ftype, fid);
                if (ftype == ::apache::thrift::protocol::T_STOP) {
                    break;
                }
                switch (fid) {
                    case 1:
                        if (ftype == ::apache::thrift::protocol::T_STRING) {
                            xfer += iprot->readString(this->guid);
                            this->__isset.guid = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    case 2:
                        if (ftype == ::apache::thrift::protocol::T_STRING) {
                            xfer += iprot->readString(this->fmiVersion);
                            this->__isset.fmiVersion = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    case 3:
                        if (ftype == ::apache::thrift::protocol::T_STRING) {
                            xfer += iprot->readString(this->modelName);
                            this->__isset.modelName = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    case 4:
                        if (ftype == ::apache::thrift::protocol::T_STRING) {
                            xfer += iprot->readString(this->license);
                            this->__isset.license = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    case 5:
                        if (ftype == ::apache::thrift::protocol::T_STRING) {
                            xfer += iprot->readString(this->copyright);
                            this->__isset.copyright = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    case 6:
                        if (ftype == ::apache::thrift::protocol::T_STRING) {
                            xfer += iprot->readString(this->author);
                            this->__isset.author = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    case 7:
                        if (ftype == ::apache::thrift::protocol::T_STRING) {
                            xfer += iprot->readString(this->version);
                            this->__isset.version = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    case 8:
                        if (ftype == ::apache::thrift::protocol::T_STRING) {
                            xfer += iprot->readString(this->description);
                            this->__isset.description = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    case 9:
                        if (ftype == ::apache::thrift::protocol::T_STRING) {
                            xfer += iprot->readString(this->generationTool);
                            this->__isset.generationTool = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    case 10:
                        if (ftype == ::apache::thrift::protocol::T_STRING) {
                            xfer += iprot->readString(this->generationDateAndTime);
                            this->__isset.generationDateAndTime = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    case 11:
                        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                            xfer += this->defaultExperiment.read(iprot);
                            this->__isset.defaultExperiment = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    case 12:
                        if (ftype == ::apache::thrift::protocol::T_STRING) {
                            xfer += iprot->readString(this->variableNamingConvention);
                            this->__isset.variableNamingConvention = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    case 13:
                        if (ftype == ::apache::thrift::protocol::T_LIST) {
                            {
                                this->modelVariables.clear();
                                uint32_t _size88;
                                ::apache::thrift::protocol::TType _etype91;
                                xfer += iprot->readListBegin(_etype91, _size88);
                                this->modelVariables.resize(_size88);
                                uint32_t _i92;
                                for (_i92 = 0; _i92 < _size88; ++_i92) {
                                    xfer += this->modelVariables[_i92].read(iprot);
                                }
                                xfer += iprot->readListEnd();
                            }
                            this->__isset.modelVariables = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    case 14:
                        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                            xfer += this->modelStructure.read(iprot);
                            this->__isset.modelStructure = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
                }
                xfer += iprot->readFieldEnd();
            }

            xfer += iprot->readStructEnd();

            return xfer;
        }

        uint32_t ModelDescription::write(::apache::thrift::protocol::TProtocol *oprot) const {
            uint32_t xfer = 0;
            ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
            xfer += oprot->writeStructBegin("ModelDescription");

            xfer += oprot->writeFieldBegin("guid", ::apache::thrift::protocol::T_STRING, 1);
            xfer += oprot->writeString(this->guid);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldBegin("fmiVersion", ::apache::thrift::protocol::T_STRING, 2);
            xfer += oprot->writeString(this->fmiVersion);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldBegin("modelName", ::apache::thrift::protocol::T_STRING, 3);
            xfer += oprot->writeString(this->modelName);
            xfer += oprot->writeFieldEnd();

            if (this->__isset.license) {
                xfer += oprot->writeFieldBegin("license", ::apache::thrift::protocol::T_STRING, 4);
                xfer += oprot->writeString(this->license);
                xfer += oprot->writeFieldEnd();
            }
            if (this->__isset.copyright) {
                xfer += oprot->writeFieldBegin("copyright", ::apache::thrift::protocol::T_STRING, 5);
                xfer += oprot->writeString(this->copyright);
                xfer += oprot->writeFieldEnd();
            }
            if (this->__isset.author) {
                xfer += oprot->writeFieldBegin("author", ::apache::thrift::protocol::T_STRING, 6);
                xfer += oprot->writeString(this->author);
                xfer += oprot->writeFieldEnd();
            }
            if (this->__isset.version) {
                xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_STRING, 7);
                xfer += oprot->writeString(this->version);
                xfer += oprot->writeFieldEnd();
            }
            if (this->__isset.description) {
                xfer += oprot->writeFieldBegin("description", ::apache::thrift::protocol::T_STRING, 8);
                xfer += oprot->writeString(this->description);
                xfer += oprot->writeFieldEnd();
            }
            if (this->__isset.generationTool) {
                xfer += oprot->writeFieldBegin("generationTool", ::apache::thrift::protocol::T_STRING, 9);
                xfer += oprot->writeString(this->generationTool);
                xfer += oprot->writeFieldEnd();
            }
            if (this->__isset.generationDateAndTime) {
                xfer += oprot->writeFieldBegin("generationDateAndTime", ::apache::thrift::protocol::T_STRING, 10);
                xfer += oprot->writeString(this->generationDateAndTime);
                xfer += oprot->writeFieldEnd();
            }
            if (this->__isset.defaultExperiment) {
                xfer += oprot->writeFieldBegin("defaultExperiment", ::apache::thrift::protocol::T_STRUCT, 11);
                xfer += this->defaultExperiment.write(oprot);
                xfer += oprot->writeFieldEnd();
            }
            if (this->__isset.variableNamingConvention) {
                xfer += oprot->writeFieldBegin("variableNamingConvention", ::apache::thrift::protocol::T_STRING, 12);
                xfer += oprot->writeString(this->variableNamingConvention);
                xfer += oprot->writeFieldEnd();
            }
            xfer += oprot->writeFieldBegin("modelVariables", ::apache::thrift::protocol::T_LIST, 13);
            {
                xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT,
                                              static_cast<uint32_t>(this->modelVariables.size()));
                std::vector<ScalarVariable>::const_iterator _iter93;
                for (_iter93 = this->modelVariables.begin(); _iter93 != this->modelVariables.end(); ++_iter93) {
                    xfer += (*_iter93).write(oprot);
                }
                xfer += oprot->writeListEnd();
            }
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldBegin("modelStructure", ::apache::thrift::protocol::T_STRUCT, 14);
            xfer += this->modelStructure.write(oprot);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldStop();
            xfer += oprot->writeStructEnd();
            return xfer;
        }

        void swap(ModelDescription &a, ModelDescription &b) {
            using ::std::swap;
            swap(a.guid, b.guid);
            swap(a.fmiVersion, b.fmiVersion);
            swap(a.modelName, b.modelName);
            swap(a.license, b.license);
            swap(a.copyright, b.copyright);
            swap(a.author, b.author);
            swap(a.version, b.version);
            swap(a.description, b.description);
            swap(a.generationTool, b.generationTool);
            swap(a.generationDateAndTime, b.generationDateAndTime);
            swap(a.defaultExperiment, b.defaultExperiment);
            swap(a.variableNamingConvention, b.variableNamingConvention);
            swap(a.modelVariables, b.modelVariables);
            swap(a.modelStructure, b.modelStructure);
            swap(a.__isset, b.__isset);
        }

        ModelDescription::ModelDescription(const ModelDescription &other94) {
            guid = other94.guid;
            fmiVersion = other94.fmiVersion;
            modelName = other94.modelName;
            license = other94.license;
            copyright = other94.copyright;
            author = other94.author;
            version = other94.version;
            description = other94.description;
            generationTool = other94.generationTool;
            generationDateAndTime = other94.generationDateAndTime;
            defaultExperiment = other94.defaultExperiment;
            variableNamingConvention = other94.variableNamingConvention;
            modelVariables = other94.modelVariables;
            modelStructure = other94.modelStructure;
            __isset = other94.__isset;
        }

        ModelDescription &ModelDescription::operator=(const ModelDescription &other95) {
            guid = other95.guid;
            fmiVersion = other95.fmiVersion;
            modelName = other95.modelName;
            license = other95.license;
            copyright = other95.copyright;
            author = other95.author;
            version = other95.version;
            description = other95.description;
            generationTool = other95.generationTool;
            generationDateAndTime = other95.generationDateAndTime;
            defaultExperiment = other95.defaultExperiment;
            variableNamingConvention = other95.variableNamingConvention;
            modelVariables = other95.modelVariables;
            modelStructure = other95.modelStructure;
            __isset = other95.__isset;
            return *this;
        }

        void ModelDescription::printTo(std::ostream &out) const {
            using ::apache::thrift::to_string;
            out << "ModelDescription(";
            out << "guid=" << to_string(guid);
            out << ", " << "fmiVersion=" << to_string(fmiVersion);
            out << ", " << "modelName=" << to_string(modelName);
            out << ", " << "license=";
            (__isset.license ? (out << to_string(license)) : (out << "<null>"));
            out << ", " << "copyright=";
            (__isset.copyright ? (out << to_string(copyright)) : (out << "<null>"));
            out << ", " << "author=";
            (__isset.author ? (out << to_string(author)) : (out << "<null>"));
            out << ", " << "version=";
            (__isset.version ? (out << to_string(version)) : (out << "<null>"));
            out << ", " << "description=";
            (__isset.description ? (out << to_string(description)) : (out << "<null>"));
            out << ", " << "generationTool=";
            (__isset.generationTool ? (out << to_string(generationTool)) : (out << "<null>"));
            out << ", " << "generationDateAndTime=";
            (__isset.generationDateAndTime ? (out << to_string(generationDateAndTime)) : (out << "<null>"));
            out << ", " << "defaultExperiment=";
            (__isset.defaultExperiment ? (out << to_string(defaultExperiment)) : (out << "<null>"));
            out << ", " << "variableNamingConvention=";
            (__isset.variableNamingConvention ? (out << to_string(variableNamingConvention)) : (out << "<null>"));
            out << ", " << "modelVariables=" << to_string(modelVariables);
            out << ", " << "modelStructure=" << to_string(modelStructure);
            out << ")";
        }


        CoSimulationAttributes::~CoSimulationAttributes() noexcept {
        }


        void CoSimulationAttributes::__set_modelIdentifier(const std::string &val) {
            this->modelIdentifier = val;
        }

        void CoSimulationAttributes::__set_canGetAndSetFMUstate(const bool val) {
            this->canGetAndSetFMUstate = val;
        }

        void CoSimulationAttributes::__set_canSerializeFMUstate(const bool val) {
            this->canSerializeFMUstate = val;
        }

        void CoSimulationAttributes::__set_providesDirectionalDerivative(const bool val) {
            this->providesDirectionalDerivative = val;
        }

        void CoSimulationAttributes::__set_canHandleVariableCommunicationStepSize(const bool val) {
            this->canHandleVariableCommunicationStepSize = val;
        }

        void CoSimulationAttributes::__set_canInterpolateInputs(const bool val) {
            this->canInterpolateInputs = val;
        }

        void CoSimulationAttributes::__set_maxOutputDerivativeOrder(const int32_t val) {
            this->maxOutputDerivativeOrder = val;
        }

        std::ostream &operator<<(std::ostream &out, const CoSimulationAttributes &obj) {
            obj.printTo(out);
            return out;
        }


        uint32_t CoSimulationAttributes::read(::apache::thrift::protocol::TProtocol *iprot) {

            ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
            uint32_t xfer = 0;
            std::string fname;
            ::apache::thrift::protocol::TType ftype;
            int16_t fid;

            xfer += iprot->readStructBegin(fname);

            using ::apache::thrift::protocol::TProtocolException;


            while (true) {
                xfer += iprot->readFieldBegin(fname, ftype, fid);
                if (ftype == ::apache::thrift::protocol::T_STOP) {
                    break;
                }
                switch (fid) {
                    case 1:
                        if (ftype == ::apache::thrift::protocol::T_STRING) {
                            xfer += iprot->readString(this->modelIdentifier);
                            this->__isset.modelIdentifier = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    case 2:
                        if (ftype == ::apache::thrift::protocol::T_BOOL) {
                            xfer += iprot->readBool(this->canGetAndSetFMUstate);
                            this->__isset.canGetAndSetFMUstate = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    case 3:
                        if (ftype == ::apache::thrift::protocol::T_BOOL) {
                            xfer += iprot->readBool(this->canSerializeFMUstate);
                            this->__isset.canSerializeFMUstate = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    case 4:
                        if (ftype == ::apache::thrift::protocol::T_BOOL) {
                            xfer += iprot->readBool(this->providesDirectionalDerivative);
                            this->__isset.providesDirectionalDerivative = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    case 5:
                        if (ftype == ::apache::thrift::protocol::T_BOOL) {
                            xfer += iprot->readBool(this->canHandleVariableCommunicationStepSize);
                            this->__isset.canHandleVariableCommunicationStepSize = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    case 6:
                        if (ftype == ::apache::thrift::protocol::T_BOOL) {
                            xfer += iprot->readBool(this->canInterpolateInputs);
                            this->__isset.canInterpolateInputs = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    case 7:
                        if (ftype == ::apache::thrift::protocol::T_I32) {
                            xfer += iprot->readI32(this->maxOutputDerivativeOrder);
                            this->__isset.maxOutputDerivativeOrder = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
                }
                xfer += iprot->readFieldEnd();
            }

            xfer += iprot->readStructEnd();

            return xfer;
        }

        uint32_t CoSimulationAttributes::write(::apache::thrift::protocol::TProtocol *oprot) const {
            uint32_t xfer = 0;
            ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
            xfer += oprot->writeStructBegin("CoSimulationAttributes");

            xfer += oprot->writeFieldBegin("modelIdentifier", ::apache::thrift::protocol::T_STRING, 1);
            xfer += oprot->writeString(this->modelIdentifier);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldBegin("canGetAndSetFMUstate", ::apache::thrift::protocol::T_BOOL, 2);
            xfer += oprot->writeBool(this->canGetAndSetFMUstate);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldBegin("canSerializeFMUstate", ::apache::thrift::protocol::T_BOOL, 3);
            xfer += oprot->writeBool(this->canSerializeFMUstate);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldBegin("providesDirectionalDerivative", ::apache::thrift::protocol::T_BOOL, 4);
            xfer += oprot->writeBool(this->providesDirectionalDerivative);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldBegin("canHandleVariableCommunicationStepSize", ::apache::thrift::protocol::T_BOOL,
                                           5);
            xfer += oprot->writeBool(this->canHandleVariableCommunicationStepSize);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldBegin("canInterpolateInputs", ::apache::thrift::protocol::T_BOOL, 6);
            xfer += oprot->writeBool(this->canInterpolateInputs);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldBegin("maxOutputDerivativeOrder", ::apache::thrift::protocol::T_I32, 7);
            xfer += oprot->writeI32(this->maxOutputDerivativeOrder);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldStop();
            xfer += oprot->writeStructEnd();
            return xfer;
        }

        void swap(CoSimulationAttributes &a, CoSimulationAttributes &b) {
            using ::std::swap;
            swap(a.modelIdentifier, b.modelIdentifier);
            swap(a.canGetAndSetFMUstate, b.canGetAndSetFMUstate);
            swap(a.canSerializeFMUstate, b.canSerializeFMUstate);
            swap(a.providesDirectionalDerivative, b.providesDirectionalDerivative);
            swap(a.canHandleVariableCommunicationStepSize, b.canHandleVariableCommunicationStepSize);
            swap(a.canInterpolateInputs, b.canInterpolateInputs);
            swap(a.maxOutputDerivativeOrder, b.maxOutputDerivativeOrder);
            swap(a.__isset, b.__isset);
        }

        CoSimulationAttributes::CoSimulationAttributes(const CoSimulationAttributes &other96) {
            modelIdentifier = other96.modelIdentifier;
            canGetAndSetFMUstate = other96.canGetAndSetFMUstate;
            canSerializeFMUstate = other96.canSerializeFMUstate;
            providesDirectionalDerivative = other96.providesDirectionalDerivative;
            canHandleVariableCommunicationStepSize = other96.canHandleVariableCommunicationStepSize;
            canInterpolateInputs = other96.canInterpolateInputs;
            maxOutputDerivativeOrder = other96.maxOutputDerivativeOrder;
            __isset = other96.__isset;
        }

        CoSimulationAttributes &CoSimulationAttributes::operator=(const CoSimulationAttributes &other97) {
            modelIdentifier = other97.modelIdentifier;
            canGetAndSetFMUstate = other97.canGetAndSetFMUstate;
            canSerializeFMUstate = other97.canSerializeFMUstate;
            providesDirectionalDerivative = other97.providesDirectionalDerivative;
            canHandleVariableCommunicationStepSize = other97.canHandleVariableCommunicationStepSize;
            canInterpolateInputs = other97.canInterpolateInputs;
            maxOutputDerivativeOrder = other97.maxOutputDerivativeOrder;
            __isset = other97.__isset;
            return *this;
        }

        void CoSimulationAttributes::printTo(std::ostream &out) const {
            using ::apache::thrift::to_string;
            out << "CoSimulationAttributes(";
            out << "modelIdentifier=" << to_string(modelIdentifier);
            out << ", " << "canGetAndSetFMUstate=" << to_string(canGetAndSetFMUstate);
            out << ", " << "canSerializeFMUstate=" << to_string(canSerializeFMUstate);
            out << ", " << "providesDirectionalDerivative=" << to_string(providesDirectionalDerivative);
            out << ", " << "canHandleVariableCommunicationStepSize="
                << to_string(canHandleVariableCommunicationStepSize);
            out << ", " << "canInterpolateInputs=" << to_string(canInterpolateInputs);
            out << ", " << "maxOutputDerivativeOrder=" << to_string(maxOutputDerivativeOrder);
            out << ")";
        }


        NoSuchFmuException::~NoSuchFmuException() noexcept {
        }


        void NoSuchFmuException::__set_message(const std::string &val) {
            this->message = val;
        }

        std::ostream &operator<<(std::ostream &out, const NoSuchFmuException &obj) {
            obj.printTo(out);
            return out;
        }


        uint32_t NoSuchFmuException::read(::apache::thrift::protocol::TProtocol *iprot) {

            ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
            uint32_t xfer = 0;
            std::string fname;
            ::apache::thrift::protocol::TType ftype;
            int16_t fid;

            xfer += iprot->readStructBegin(fname);

            using ::apache::thrift::protocol::TProtocolException;


            while (true) {
                xfer += iprot->readFieldBegin(fname, ftype, fid);
                if (ftype == ::apache::thrift::protocol::T_STOP) {
                    break;
                }
                switch (fid) {
                    case 1:
                        if (ftype == ::apache::thrift::protocol::T_STRING) {
                            xfer += iprot->readString(this->message);
                            this->__isset.message = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
                }
                xfer += iprot->readFieldEnd();
            }

            xfer += iprot->readStructEnd();

            return xfer;
        }

        uint32_t NoSuchFmuException::write(::apache::thrift::protocol::TProtocol *oprot) const {
            uint32_t xfer = 0;
            ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
            xfer += oprot->writeStructBegin("NoSuchFmuException");

            xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
            xfer += oprot->writeString(this->message);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldStop();
            xfer += oprot->writeStructEnd();
            return xfer;
        }

        void swap(NoSuchFmuException &a, NoSuchFmuException &b) {
            using ::std::swap;
            swap(a.message, b.message);
            swap(a.__isset, b.__isset);
        }

        NoSuchFmuException::NoSuchFmuException(const NoSuchFmuException &other98) : TException() {
            message = other98.message;
            __isset = other98.__isset;
        }

        NoSuchFmuException &NoSuchFmuException::operator=(const NoSuchFmuException &other99) {
            message = other99.message;
            __isset = other99.__isset;
            return *this;
        }

        void NoSuchFmuException::printTo(std::ostream &out) const {
            using ::apache::thrift::to_string;
            out << "NoSuchFmuException(";
            out << "message=" << to_string(message);
            out << ")";
        }

        const char *NoSuchFmuException::what() const noexcept {
            try {
                std::stringstream ss;
                ss << "TException - service has thrown: " << *this;
                this->thriftTExceptionMessageHolder_ = ss.str();
                return this->thriftTExceptionMessageHolder_.c_str();
            } catch (const std::exception &) {
                return "TException - service has thrown: NoSuchFmuException";
            }
        }


        NoSuchInstanceException::~NoSuchInstanceException() noexcept {
        }


        void NoSuchInstanceException::__set_message(const std::string &val) {
            this->message = val;
        }

        std::ostream &operator<<(std::ostream &out, const NoSuchInstanceException &obj) {
            obj.printTo(out);
            return out;
        }


        uint32_t NoSuchInstanceException::read(::apache::thrift::protocol::TProtocol *iprot) {

            ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
            uint32_t xfer = 0;
            std::string fname;
            ::apache::thrift::protocol::TType ftype;
            int16_t fid;

            xfer += iprot->readStructBegin(fname);

            using ::apache::thrift::protocol::TProtocolException;


            while (true) {
                xfer += iprot->readFieldBegin(fname, ftype, fid);
                if (ftype == ::apache::thrift::protocol::T_STOP) {
                    break;
                }
                switch (fid) {
                    case 1:
                        if (ftype == ::apache::thrift::protocol::T_STRING) {
                            xfer += iprot->readString(this->message);
                            this->__isset.message = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
                }
                xfer += iprot->readFieldEnd();
            }

            xfer += iprot->readStructEnd();

            return xfer;
        }

        uint32_t NoSuchInstanceException::write(::apache::thrift::protocol::TProtocol *oprot) const {
            uint32_t xfer = 0;
            ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
            xfer += oprot->writeStructBegin("NoSuchInstanceException");

            xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
            xfer += oprot->writeString(this->message);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldStop();
            xfer += oprot->writeStructEnd();
            return xfer;
        }

        void swap(NoSuchInstanceException &a, NoSuchInstanceException &b) {
            using ::std::swap;
            swap(a.message, b.message);
            swap(a.__isset, b.__isset);
        }

        NoSuchInstanceException::NoSuchInstanceException(const NoSuchInstanceException &other100) : TException() {
            message = other100.message;
            __isset = other100.__isset;
        }

        NoSuchInstanceException &NoSuchInstanceException::operator=(const NoSuchInstanceException &other101) {
            message = other101.message;
            __isset = other101.__isset;
            return *this;
        }

        void NoSuchInstanceException::printTo(std::ostream &out) const {
            using ::apache::thrift::to_string;
            out << "NoSuchInstanceException(";
            out << "message=" << to_string(message);
            out << ")";
        }

        const char *NoSuchInstanceException::what() const noexcept {
            try {
                std::stringstream ss;
                ss << "TException - service has thrown: " << *this;
                this->thriftTExceptionMessageHolder_ = ss.str();
                return this->thriftTExceptionMessageHolder_.c_str();
            } catch (const std::exception &) {
                return "TException - service has thrown: NoSuchInstanceException";
            }
        }


        NoSuchVariableException::~NoSuchVariableException() noexcept {
        }


        void NoSuchVariableException::__set_message(const std::string &val) {
            this->message = val;
        }

        std::ostream &operator<<(std::ostream &out, const NoSuchVariableException &obj) {
            obj.printTo(out);
            return out;
        }


        uint32_t NoSuchVariableException::read(::apache::thrift::protocol::TProtocol *iprot) {

            ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
            uint32_t xfer = 0;
            std::string fname;
            ::apache::thrift::protocol::TType ftype;
            int16_t fid;

            xfer += iprot->readStructBegin(fname);

            using ::apache::thrift::protocol::TProtocolException;


            while (true) {
                xfer += iprot->readFieldBegin(fname, ftype, fid);
                if (ftype == ::apache::thrift::protocol::T_STOP) {
                    break;
                }
                switch (fid) {
                    case 1:
                        if (ftype == ::apache::thrift::protocol::T_STRING) {
                            xfer += iprot->readString(this->message);
                            this->__isset.message = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
                }
                xfer += iprot->readFieldEnd();
            }

            xfer += iprot->readStructEnd();

            return xfer;
        }

        uint32_t NoSuchVariableException::write(::apache::thrift::protocol::TProtocol *oprot) const {
            uint32_t xfer = 0;
            ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
            xfer += oprot->writeStructBegin("NoSuchVariableException");

            xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
            xfer += oprot->writeString(this->message);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldStop();
            xfer += oprot->writeStructEnd();
            return xfer;
        }

        void swap(NoSuchVariableException &a, NoSuchVariableException &b) {
            using ::std::swap;
            swap(a.message, b.message);
            swap(a.__isset, b.__isset);
        }

        NoSuchVariableException::NoSuchVariableException(const NoSuchVariableException &other102) : TException() {
            message = other102.message;
            __isset = other102.__isset;
        }

        NoSuchVariableException &NoSuchVariableException::operator=(const NoSuchVariableException &other103) {
            message = other103.message;
            __isset = other103.__isset;
            return *this;
        }

        void NoSuchVariableException::printTo(std::ostream &out) const {
            using ::apache::thrift::to_string;
            out << "NoSuchVariableException(";
            out << "message=" << to_string(message);
            out << ")";
        }

        const char *NoSuchVariableException::what() const noexcept {
            try {
                std::stringstream ss;
                ss << "TException - service has thrown: " << *this;
                this->thriftTExceptionMessageHolder_ = ss.str();
                return this->thriftTExceptionMessageHolder_.c_str();
            } catch (const std::exception &) {
                return "TException - service has thrown: NoSuchVariableException";
            }
        }


        UnsupportedOperationException::~UnsupportedOperationException() noexcept {
        }


        void UnsupportedOperationException::__set_message(const std::string &val) {
            this->message = val;
        }

        std::ostream &operator<<(std::ostream &out, const UnsupportedOperationException &obj) {
            obj.printTo(out);
            return out;
        }


        uint32_t UnsupportedOperationException::read(::apache::thrift::protocol::TProtocol *iprot) {

            ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
            uint32_t xfer = 0;
            std::string fname;
            ::apache::thrift::protocol::TType ftype;
            int16_t fid;

            xfer += iprot->readStructBegin(fname);

            using ::apache::thrift::protocol::TProtocolException;


            while (true) {
                xfer += iprot->readFieldBegin(fname, ftype, fid);
                if (ftype == ::apache::thrift::protocol::T_STOP) {
                    break;
                }
                switch (fid) {
                    case 1:
                        if (ftype == ::apache::thrift::protocol::T_STRING) {
                            xfer += iprot->readString(this->message);
                            this->__isset.message = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
                }
                xfer += iprot->readFieldEnd();
            }

            xfer += iprot->readStructEnd();

            return xfer;
        }

        uint32_t UnsupportedOperationException::write(::apache::thrift::protocol::TProtocol *oprot) const {
            uint32_t xfer = 0;
            ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
            xfer += oprot->writeStructBegin("UnsupportedOperationException");

            xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
            xfer += oprot->writeString(this->message);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldStop();
            xfer += oprot->writeStructEnd();
            return xfer;
        }

        void swap(UnsupportedOperationException &a, UnsupportedOperationException &b) {
            using ::std::swap;
            swap(a.message, b.message);
            swap(a.__isset, b.__isset);
        }

        UnsupportedOperationException::UnsupportedOperationException(const UnsupportedOperationException &other104)
                : TException() {
            message = other104.message;
            __isset = other104.__isset;
        }

        UnsupportedOperationException &
        UnsupportedOperationException::operator=(const UnsupportedOperationException &other105) {
            message = other105.message;
            __isset = other105.__isset;
            return *this;
        }

        void UnsupportedOperationException::printTo(std::ostream &out) const {
            using ::apache::thrift::to_string;
            out << "UnsupportedOperationException(";
            out << "message=" << to_string(message);
            out << ")";
        }

        const char *UnsupportedOperationException::what() const noexcept {
            try {
                std::stringstream ss;
                ss << "TException - service has thrown: " << *this;
                this->thriftTExceptionMessageHolder_ = ss.str();
                return this->thriftTExceptionMessageHolder_.c_str();
            } catch (const std::exception &) {
                return "TException - service has thrown: UnsupportedOperationException";
            }
        }


        GetFmuStateResult::~GetFmuStateResult() noexcept {
        }


        void GetFmuStateResult::__set_state(const FmuState val) {
            this->state = val;
        }

        void GetFmuStateResult::__set_status(const Status::type val) {
            this->status = val;
        }

        std::ostream &operator<<(std::ostream &out, const GetFmuStateResult &obj) {
            obj.printTo(out);
            return out;
        }


        uint32_t GetFmuStateResult::read(::apache::thrift::protocol::TProtocol *iprot) {

            ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
            uint32_t xfer = 0;
            std::string fname;
            ::apache::thrift::protocol::TType ftype;
            int16_t fid;

            xfer += iprot->readStructBegin(fname);

            using ::apache::thrift::protocol::TProtocolException;


            while (true) {
                xfer += iprot->readFieldBegin(fname, ftype, fid);
                if (ftype == ::apache::thrift::protocol::T_STOP) {
                    break;
                }
                switch (fid) {
                    case 1:
                        if (ftype == ::apache::thrift::protocol::T_I64) {
                            xfer += iprot->readI64(this->state);
                            this->__isset.state = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    case 2:
                        if (ftype == ::apache::thrift::protocol::T_I32) {
                            int32_t ecast106;
                            xfer += iprot->readI32(ecast106);
                            this->status = (Status::type) ecast106;
                            this->__isset.status = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
                }
                xfer += iprot->readFieldEnd();
            }

            xfer += iprot->readStructEnd();

            return xfer;
        }

        uint32_t GetFmuStateResult::write(::apache::thrift::protocol::TProtocol *oprot) const {
            uint32_t xfer = 0;
            ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
            xfer += oprot->writeStructBegin("GetFmuStateResult");

            xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_I64, 1);
            xfer += oprot->writeI64(this->state);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 2);
            xfer += oprot->writeI32((int32_t) this->status);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldStop();
            xfer += oprot->writeStructEnd();
            return xfer;
        }

        void swap(GetFmuStateResult &a, GetFmuStateResult &b) {
            using ::std::swap;
            swap(a.state, b.state);
            swap(a.status, b.status);
            swap(a.__isset, b.__isset);
        }

        GetFmuStateResult::GetFmuStateResult(const GetFmuStateResult &other107) {
            state = other107.state;
            status = other107.status;
            __isset = other107.__isset;
        }

        GetFmuStateResult &GetFmuStateResult::operator=(const GetFmuStateResult &other108) {
            state = other108.state;
            status = other108.status;
            __isset = other108.__isset;
            return *this;
        }

        void GetFmuStateResult::printTo(std::ostream &out) const {
            using ::apache::thrift::to_string;
            out << "GetFmuStateResult(";
            out << "state=" << to_string(state);
            out << ", " << "status=" << to_string(status);
            out << ")";
        }


        SerializeFmuStateResult::~SerializeFmuStateResult() noexcept {
        }


        void SerializeFmuStateResult::__set_state(const std::string &val) {
            this->state = val;
        }

        void SerializeFmuStateResult::__set_status(const Status::type val) {
            this->status = val;
        }

        std::ostream &operator<<(std::ostream &out, const SerializeFmuStateResult &obj) {
            obj.printTo(out);
            return out;
        }


        uint32_t SerializeFmuStateResult::read(::apache::thrift::protocol::TProtocol *iprot) {

            ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
            uint32_t xfer = 0;
            std::string fname;
            ::apache::thrift::protocol::TType ftype;
            int16_t fid;

            xfer += iprot->readStructBegin(fname);

            using ::apache::thrift::protocol::TProtocolException;


            while (true) {
                xfer += iprot->readFieldBegin(fname, ftype, fid);
                if (ftype == ::apache::thrift::protocol::T_STOP) {
                    break;
                }
                switch (fid) {
                    case 1:
                        if (ftype == ::apache::thrift::protocol::T_STRING) {
                            xfer += iprot->readBinary(this->state);
                            this->__isset.state = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    case 2:
                        if (ftype == ::apache::thrift::protocol::T_I32) {
                            int32_t ecast109;
                            xfer += iprot->readI32(ecast109);
                            this->status = (Status::type) ecast109;
                            this->__isset.status = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
                }
                xfer += iprot->readFieldEnd();
            }

            xfer += iprot->readStructEnd();

            return xfer;
        }

        uint32_t SerializeFmuStateResult::write(::apache::thrift::protocol::TProtocol *oprot) const {
            uint32_t xfer = 0;
            ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
            xfer += oprot->writeStructBegin("SerializeFmuStateResult");

            xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_STRING, 1);
            xfer += oprot->writeBinary(this->state);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 2);
            xfer += oprot->writeI32((int32_t) this->status);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldStop();
            xfer += oprot->writeStructEnd();
            return xfer;
        }

        void swap(SerializeFmuStateResult &a, SerializeFmuStateResult &b) {
            using ::std::swap;
            swap(a.state, b.state);
            swap(a.status, b.status);
            swap(a.__isset, b.__isset);
        }

        SerializeFmuStateResult::SerializeFmuStateResult(const SerializeFmuStateResult &other110) {
            state = other110.state;
            status = other110.status;
            __isset = other110.__isset;
        }

        SerializeFmuStateResult &SerializeFmuStateResult::operator=(const SerializeFmuStateResult &other111) {
            state = other111.state;
            status = other111.status;
            __isset = other111.__isset;
            return *this;
        }

        void SerializeFmuStateResult::printTo(std::ostream &out) const {
            using ::apache::thrift::to_string;
            out << "SerializeFmuStateResult(";
            out << "state=" << to_string(state);
            out << ", " << "status=" << to_string(status);
            out << ")";
        }


        DeSerializeFmuStateResult::~DeSerializeFmuStateResult() noexcept {
        }


        void DeSerializeFmuStateResult::__set_state(const FmuState val) {
            this->state = val;
        }

        void DeSerializeFmuStateResult::__set_status(const Status::type val) {
            this->status = val;
        }

        std::ostream &operator<<(std::ostream &out, const DeSerializeFmuStateResult &obj) {
            obj.printTo(out);
            return out;
        }


        uint32_t DeSerializeFmuStateResult::read(::apache::thrift::protocol::TProtocol *iprot) {

            ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
            uint32_t xfer = 0;
            std::string fname;
            ::apache::thrift::protocol::TType ftype;
            int16_t fid;

            xfer += iprot->readStructBegin(fname);

            using ::apache::thrift::protocol::TProtocolException;


            while (true) {
                xfer += iprot->readFieldBegin(fname, ftype, fid);
                if (ftype == ::apache::thrift::protocol::T_STOP) {
                    break;
                }
                switch (fid) {
                    case 1:
                        if (ftype == ::apache::thrift::protocol::T_I64) {
                            xfer += iprot->readI64(this->state);
                            this->__isset.state = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    case 2:
                        if (ftype == ::apache::thrift::protocol::T_I32) {
                            int32_t ecast112;
                            xfer += iprot->readI32(ecast112);
                            this->status = (Status::type) ecast112;
                            this->__isset.status = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
                }
                xfer += iprot->readFieldEnd();
            }

            xfer += iprot->readStructEnd();

            return xfer;
        }

        uint32_t DeSerializeFmuStateResult::write(::apache::thrift::protocol::TProtocol *oprot) const {
            uint32_t xfer = 0;
            ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
            xfer += oprot->writeStructBegin("DeSerializeFmuStateResult");

            xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_I64, 1);
            xfer += oprot->writeI64(this->state);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 2);
            xfer += oprot->writeI32((int32_t) this->status);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldStop();
            xfer += oprot->writeStructEnd();
            return xfer;
        }

        void swap(DeSerializeFmuStateResult &a, DeSerializeFmuStateResult &b) {
            using ::std::swap;
            swap(a.state, b.state);
            swap(a.status, b.status);
            swap(a.__isset, b.__isset);
        }

        DeSerializeFmuStateResult::DeSerializeFmuStateResult(const DeSerializeFmuStateResult &other113) {
            state = other113.state;
            status = other113.status;
            __isset = other113.__isset;
        }

        DeSerializeFmuStateResult &DeSerializeFmuStateResult::operator=(const DeSerializeFmuStateResult &other114) {
            state = other114.state;
            status = other114.status;
            __isset = other114.__isset;
            return *this;
        }

        void DeSerializeFmuStateResult::printTo(std::ostream &out) const {
            using ::apache::thrift::to_string;
            out << "DeSerializeFmuStateResult(";
            out << "state=" << to_string(state);
            out << ", " << "status=" << to_string(status);
            out << ")";
        }


        DirectionalDerivativeResult::~DirectionalDerivativeResult() noexcept {
        }


        void DirectionalDerivativeResult::__set_dvUnknownRef(const DirectionalDerivative &val) {
            this->dvUnknownRef = val;
        }

        void DirectionalDerivativeResult::__set_status(const Status::type val) {
            this->status = val;
        }

        std::ostream &operator<<(std::ostream &out, const DirectionalDerivativeResult &obj) {
            obj.printTo(out);
            return out;
        }


        uint32_t DirectionalDerivativeResult::read(::apache::thrift::protocol::TProtocol *iprot) {

            ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
            uint32_t xfer = 0;
            std::string fname;
            ::apache::thrift::protocol::TType ftype;
            int16_t fid;

            xfer += iprot->readStructBegin(fname);

            using ::apache::thrift::protocol::TProtocolException;


            while (true) {
                xfer += iprot->readFieldBegin(fname, ftype, fid);
                if (ftype == ::apache::thrift::protocol::T_STOP) {
                    break;
                }
                switch (fid) {
                    case 1:
                        if (ftype == ::apache::thrift::protocol::T_LIST) {
                            {
                                this->dvUnknownRef.clear();
                                uint32_t _size115;
                                ::apache::thrift::protocol::TType _etype118;
                                xfer += iprot->readListBegin(_etype118, _size115);
                                this->dvUnknownRef.resize(_size115);
                                uint32_t _i119;
                                for (_i119 = 0; _i119 < _size115; ++_i119) {
                                    xfer += iprot->readDouble(this->dvUnknownRef[_i119]);
                                }
                                xfer += iprot->readListEnd();
                            }
                            this->__isset.dvUnknownRef = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    case 2:
                        if (ftype == ::apache::thrift::protocol::T_I32) {
                            int32_t ecast120;
                            xfer += iprot->readI32(ecast120);
                            this->status = (Status::type) ecast120;
                            this->__isset.status = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
                }
                xfer += iprot->readFieldEnd();
            }

            xfer += iprot->readStructEnd();

            return xfer;
        }

        uint32_t DirectionalDerivativeResult::write(::apache::thrift::protocol::TProtocol *oprot) const {
            uint32_t xfer = 0;
            ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
            xfer += oprot->writeStructBegin("DirectionalDerivativeResult");

            xfer += oprot->writeFieldBegin("dvUnknownRef", ::apache::thrift::protocol::T_LIST, 1);
            {
                xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE,
                                              static_cast<uint32_t>(this->dvUnknownRef.size()));
                std::vector<double>::const_iterator _iter121;
                for (_iter121 = this->dvUnknownRef.begin(); _iter121 != this->dvUnknownRef.end(); ++_iter121) {
                    xfer += oprot->writeDouble((*_iter121));
                }
                xfer += oprot->writeListEnd();
            }
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 2);
            xfer += oprot->writeI32((int32_t) this->status);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldStop();
            xfer += oprot->writeStructEnd();
            return xfer;
        }

        void swap(DirectionalDerivativeResult &a, DirectionalDerivativeResult &b) {
            using ::std::swap;
            swap(a.dvUnknownRef, b.dvUnknownRef);
            swap(a.status, b.status);
            swap(a.__isset, b.__isset);
        }

        DirectionalDerivativeResult::DirectionalDerivativeResult(const DirectionalDerivativeResult &other122) {
            dvUnknownRef = other122.dvUnknownRef;
            status = other122.status;
            __isset = other122.__isset;
        }

        DirectionalDerivativeResult &
        DirectionalDerivativeResult::operator=(const DirectionalDerivativeResult &other123) {
            dvUnknownRef = other123.dvUnknownRef;
            status = other123.status;
            __isset = other123.__isset;
            return *this;
        }

        void DirectionalDerivativeResult::printTo(std::ostream &out) const {
            using ::apache::thrift::to_string;
            out << "DirectionalDerivativeResult(";
            out << "dvUnknownRef=" << to_string(dvUnknownRef);
            out << ", " << "status=" << to_string(status);
            out << ")";
        }

    }
} // namespace
